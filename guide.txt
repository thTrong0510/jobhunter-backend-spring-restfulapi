Cần làm check lại: 
    - khi fetch phải đồng bộ optional -> và kiểm tra nó có isPresent hay ko all 
    - tên các nested class
    - Làm thêm các DTO (thêm DTO cho Resume khi tạo -> vì nếu để nó trả ra User -> lấy all thông tin user mà nếu ko cho trả ra user sẽ bị lỗi vì ko có id)
    - việc gọi nhiều lần 1 api như getAccount để lấy thông tin và quyền được lặp lại khá nhiều lần 
    -> có thể viết thêm API ở backend để lưu thông tin vào localStorage Để hạn chế lần gọi API

    - tìm hiểu sử dụng log thay cho System.out.println 

===== Chapter 3: Hello World với Spring REST ====

##1 - Hello World##

- Check code kết nối tới database mysql Đảm bảo rằng bạn đã cài đặt MySQL Workbench, và có tài khoản đăng nhập vào database.
//build.gradle.kts => nhấn chuột phải, chọn “Reload projects)
	Enable 2 dependencies là jpa và mysql -> khi enable 2 dependencies này -> cần phải cấu hình thêm thông tin kết nối xuống database nếu ko sẽ lỗi 

- thư viện spring-boot-devtools giúp tự động update reload dự án khi bấm lưu code

##2 - Cấu trúc dự án thực hành##

- Trong dự án này sử dụng 1 Built Tools là Gradle chứ ko pải maven là công cụ giúp built/chạy dự án 
	settings.gradle.kts: cung cấp tên dự án, một số thông tin bổ sung meta data
	build.gradle.kts: nói cho Gradle biết
		code ngôn ngữ gì, dịch code ntn
		chạy java version nào
		nơi nào kéo các thư viện về repositories {mavenCentral()} đây là kéo từ Maven Repository sau này nếu có 1 số thư viện tự code/private -> định nghĩa thêm vào đây 
		cuối cùng là định nghĩa những thư viện nào cần dùng
			actuator: kiểm tra hệ thống 
			data-jpa: giúp kết nối xuống database (ORM)
			security: login và phân quyền người dùng 
			các thư viện liên quan đến thymeleaf: làm chức năng gửi email 
			validation: validate dữ liệu 	
			starter-web: dùng để chạy server/ứng dụng lên 
			boot-devtools: khi bấm lưu code hệ thống/server sẽ tự restart lại 
			mysql-connector-j: giúp chạy được mysql trong ứng dụng 
			những cái test là liên quan đến viết test case 
	thư mục gradle/ giúp cấu hình sẵn (version của gradle, ...) khi kéo về đã cấu hình sẵn ko cần cài lại 

- thư mục src: 
+ main: thư mục viết code
	java: viết code java
		file main: nơi bắt đầu chạy dự án
	config: config security, json web token, filter với security
	repository: định nghĩa công cụ kết nối xuống database, những function muốn truy cập xuống database 
	service: là cầu nối từ controller gọi xuống service -> repository 
	domain: định nghĩa các model, actor, tale lưu vào database 
	controller: điều hướng trang, định nghĩa các route 
	resources: lưu các tài nguyên
	
+ test: viết test case

- các thư mục ẩn:
	.vscode: đây là thư mục được sinh ra để cấu hình cách thức chạy dự án từ file lauch.json file này được sinh ra khi bấm chạy chương trình ở dashboard 

	.gradle/bin: là 2 thư mục cần dùng của gradle làm sao để dịch code sẽ dịch code sang các file class vào thư mục bin hoặc sẽ lưu vào thư mục Build nếu dự án chưa có/ko có thư mục này thì chạy lệnh ./gradlew bootRun

- Những file có tiền tố "gradle" là công cụ build dự án, hiểu một cách đơn giản:
	+ quản lý các thư viện cài đặt
	+ dịch code/build/run 

	+ bao gồm: 
		buld.gradle.kts
		gradlew (gradlew.bat)
		settings.gradle.kts

- Gradle
	Giúp bạn: Dịch code java -> .class vì java Virtual Machine chạy file class (ngôn ngữ tự nhiên -> ngôn ngữ máy)
	Copy phần resource vào thư mục build
	Tạo file jar: triên khai dự án ntn
	Run test: test case 
	And more…
Về Gradle: https://www.youtube.com/watch?v=R6Z-Sxb837I

- Sử dụng gradle:
	Run dự án Spring Boot:
		gradle bootRun
		./gradle bootRun

	Build file jar: gradlew bootJar

	hiện tại đan sử dụng Gradle Koltin(dùng nhiều hơn) chứ ko pải Gradle Groovy 

- So sánh Gradle và các công cụ khác
Tham khảo:
https://stackoverflow.com/questions/45335874/gradle-what-is-the-benefit-if-i-switch-from-groovy-to-kotlin

Maven vs Gradle
https://gradle.org/maven-vs-gradle/

Về lý do tại sao tồn tại song song thư mục bin và thư mục build: (open issue)
https://github.com/redhat-developer/vscode-java/issues/2338

-> nếu có các lỗi khi chạy chương trình (ko pải lỗi cú pháp/lỗi code) -> đem dự án sang chạy ở IDE dùng cho java để nó config lại rồi đem về vscode chạy 


====Chapter 4 CRUD User với Restful API====

##I - Tổng quan các kiến thức sẽ học##

1. Nội dung sẽ học
- Phát triển REST APIs với Spring ( @RestController )
- Tìm hiểu các khái niệm liên quan tới REST APIs, JSON và giao thức HTTP
- Sử dụng Postman để test API

2. Vấn đề tồn đọng

Dưới góc nhìn của Developer (DEV)
Ví dụ học Spring MVC dự án laptopshop khi thực hiện hành động nào đó phía frontend nếu ko có sự can thiệp của javascript -> load lại trang 

Dưới góc nhìn của business (phân tích nghiệp vụ):
Ví dụ: Xây dựng ứng dụng Weather App 

Chắc chắn thông tin (dữ liệu) về Thời tiết, bạn sẽ không có, cần phụ thuộc vào bên thứ 3 cung cấp dịch vụ
(ví dụ Trung tâm Dự báo Khí tượng thủy văn Quốc gia)

Kiến trúc dự án:
My Weather App (Client) ---------> Weather Service (Server)

ở đây mình đi mua dữ liệu từ server của third party -> làm sao để kết nối giữa ứng dụng mình với server cung cấp dịch vụ/thông tin -> Làm sao để kết nối giữa client và server ?
	Sử dụng REST API thông qua giao thức http
	REST : REpresentational State Transfer

- Ngôn ngữ lập trình nào được sử dụng ?
REST không phụ thuộc vào ngôn ngữ lập trình
-> viết Client/Server bằng ngôn ngữ bạn muốn: Java, C#, PHP, Javascript, Python...

- Sử dụng định dạng data nào (data format) ?
JSON và XML được dùng
JSON sử dụng phổ biến nhất
JSON : JavaScript Object Notation

##II - JSON##

Tham khảo: https://www.w3schools.com/js/js_json_intro.asp

1. JSON là gì
- JavaScript Object Notation
- Là 1 định dạng để lưu trữ và trao đổi dữ liệu (mà không mã hóa gì hết / plain text)
- Được sử dụng ở nhiều ngôn ngữ khác nhau: Java, C#, Javascript ...

2. Cú pháp
Ví dụ về JSON:
{
"id": 1,
"name": "Hỏi Dân IT",
"age": 25,
"active": true
}

1 Json như thế này tương tự như 1 class của chúng ta - nhưng đối với Javascript thì gọi là Object 

- Sử dụng dấu { //data } để định nghĩa JSON
- Các thuộc tính được định nghĩa theo quy luật:  
	name: value (ngăn cách với nhau bởi dấu hai chấm)

Thuộc tính name luôn được bọc bởi " " (double quotes)

3. JSON values
- number
- string
- boolean
- nested JSON object
- Array
- null

//todo : json với nested object

4. JSON so với XML 
- đối với XML thì dùng các tag giống như html 
- đối với JSON {} -> giống ngôn ngữ tự nhiên hơn 

##III - API là gì##

Tham khảo: https://jsonplaceholder.typicode.com/

1. HTTP là gì
Tham khảo: https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview

HTTP Method ----------> CRUD Operation
POST ------------ Create a new entity
GET ------------- Read a list of entities or single entity
PUT ------------- Update an existing entity
DELETE ---------- Delete an existing entity

2. Cấu trúc HTTP Request
- Request line : method + URL
- Header variables
- Message body: json

3. API
API, hiểu đơn giản, là một đường link URL được định nghĩa tại backend
frontend ko tạo/viết được API 

Frontend sẽ gọi tới đường link URL được định nghĩa ở Backend này để lấy/sử dụng dữ liệu.

4. Status code
- khi dùng API không thể thiếu trạng thái phản hồi thông qua được biểu hiện thông qua các số 
Tham khảo: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

HTTP response status codes
	Informational responses (100 – 199)
	Successful responses (200 – 299)
	Redirection messages (300 – 399)
	Client error responses (400 – 499)
	Server error responses (500 – 599)

##IV - Test API với Postman##

Tham khảo:
https://jsonplaceholder.typicode.com/ trang fake API 

Test: URI https://jsonplaceholder.typicode.com/todos/1 (GET): các thông tin cần chú ý
	status code: 200 -> lấy thông tin thành công ko lỗi 
	kiểu data nên để dưới dạng JSON -> hiển thị đẹp hơn 
	Method: 
		GET: lấy tất cả nguồn tài nguyên 
		POST ...
API ở đây đơn giản là 1 đường link URL 


Lợi thế của postman so với browser:
- Đối với đường link URL trên nếu dán vào browser vẫn ra thông tin cần lấy nhưng chỉ dùng cho mỗi Method GET
- Đối với 1 API ngoài việc truyền vào URL có thể truyền thêm các tham số khác như: headers, ...

Để xem all thông tin của API thì bấm inspect + network + all + refresh + name({;}1) -> hiển thị bên phải là header + phần preview là thông tin GET về được 

##V - API##

1 - Test API trong Postman:
- khi test url + method thì trong controller phải có url ứng với method đó nếu ko nó sẽ ko hoạt động 

- Method GET: trường hợp create user ko dùng được method GET vì nó ko truyền được nhiều data, nếu dùng method GET phải truyền data trên URL (mà URL chỉ dài được 2048 kí tự -> hạn chế dữ liệu) + không an toàn thông tin 
	-> Method GET chỉ nếu dùng là gửi yêu cầu để lấy thông tin từ server về client ~ chứ ko nên dùng để gửi thông tin từ client đến server
	-> để gửi thông tin từ client -> server thì dùng method POST 
	Khi bấm send (dùng API) thì nó cũng như dùng với trình duyệt cũng sẽ chạy code của controller của URL đó 

- Method POST:
	Truyền Data kèm theo request: trong postman có 1 option (dưới điền url) là body đối với 1 lời gọi request ta có thể đính kèm dữ liệu thêm cho nó 

	chọn Body - raw - JSON: viết đối tượng người dùng muốn tạo hiện tại (model user: name, email, password)
		{"name": "Van Huy", "email":"vanhuy@gmail.com", "password":"123"}
	-> ở phía server làm sao để lấy được data này -> dùng Annotation @RequestBody
	
- Annotation @RequestBody
	Tài liệu: https://docs.spring.io/spring-framework/reference/6.0/web/webmvc/mvc-controller/ann-methods/requestbody.html
	cách dùng: bên trong tham số hàm controller đó dùng @RequestBody + Đối tượng -> nó sẽ mapping từ data trong postman đến đối tượng (tên thuộc tính trong JSON - tên trường thông tin của đối tượng) tức nó sẽ convert từ JSON -> kiểu dữ liệu đối tượng 
	Khi ko set ID (mặc định ID sẽ = 0 hoặc = null) -> đối với Spring nó chỉ có 1 hàm là save() nếu ID = 0 || null nó sẽ mặc định hiểu là Create nếu ID khác thì nó sẽ hiểu là Update

	Khi bấm send thay vì nhận 1 chuỗi String -> có thể nhận 1 đối tượng đã gửi lên (thông tin user lúc này sẽ khác so với thông tin user đã gửi lên = có thêm id) = cách thay dữ liệu trả về = 1 User 

	Tại sao chỉ cầm thêm @RequestBody đã có thể convert từ JSON -> User (gửi data lên server) và ngược lại (nhận thông tin từ server)
		Java JSON Data Binding
		Data binding là quá trình convert JSON data thành Java POJO (Java Object) hoặc ngược lại.
		Spring sử dụng Jackson Project (behind the scenes) đây là 1 thư viện được tự động kéo về khi cài thư viện spring-boot-starter-web 
		link xem thông tin về Jackson https://github.com/FasterXML/jackson
		link xem các thư viện trong spring-boot-starter-web: có Jackson https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-starters/spring-boot-starter-json/build.gradle

- Annotation @PathVariable
	Tài liệu: https://www.baeldung.com/spring-pathvariable
	Sửa lại URL: POST (CREATE): http://localhost:8080/user
	Làm chức năng xóa user by id: DELETE (Xóa): http://localhost:8080/user/${user-id}

##2 - Tổng Kết Về RESTful (Basic)##
- Chuẩn RESTful
Ứng với tác vụ CRUD:

GET (READ) - Đọc thông tin 
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET
	Được dùng để lấy data 
	không truyền data ở body
	Có thể truyền data ở url (ví dụ delete by id - @PathVariable)

POST (CREATE) - Tạo mới thông tin 
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST
	Được dùng để truyền data lên Server 
	Có thể truyền data ở body request (@RequestBody)

PUT/PATCH  (UPDATE) - Cập nhật thông tin
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH
	Được dùng để truyền data lên Server 
	Có thể truyền data ở body request (@RequestBody)
	PUT: cập nhật ghi đè lại nguyên đối tượng
	PATCH: cập nhật ghi đè một số trường thông tin 
	

DELETE (DELETE) - Xóa thông tin
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE
	Được dùng để xóa data 
	Có thể truyền data ở url (ví dụ delete by id - @PathVariable)

##3 - Spring Data Rest Project (Extra)##
Tài liệu: https://spring.io/projects/spring-data-rest

1.Spring Data Rest
Tự động tạo endpoint (api) ứng với domain (model) mà không cần viết code.
	Ví dụ, bạn có Entity là User, nó sẽ tự động tạo : 
	GET /users
	POST /users …
Có thể tùy chỉnh (customize) để phục vụ API của JPA, như paging, sorting…

2. So sánh Spring Data Rest và @RestController  
Nhược điểm của đứa này, là ưu điểm của đứa kia :v
Spring Data Rest: code ngắn, phù hợp để phát triển ứng dụng một cách nhanh nhất có thể (vì code rất ít). Vì vậy, phù hợp để giải quyết tác vụ CRUD đơn giản.
@RestController  :  code dài hơn. 100% kiểm soát code 


====Chapter 5: Response Entity====
Xử lý phản hồi của API với Response Entity

##I - Tại sao cần Response Entity##

Mô hình đang thực hiện: client -> server
Cụ thể: client (browser/postman) gửi request (yêu cầu)  tới server (java) thông qua RESTful APIs

Server (java) gửi response (phản hồi) về cho client

Hiện tại, phản hồi (response) đang ở dạng text, hoặc JSON object

Để các hệ thống nói chuyện với nhau 1 cách đầy đủ nhất, 1 lời phản hồi (response) sẽ gồm:
	- Thông tin header (ví dụ bạn muốn dùng cookies chẳng hạn)
	- Thông tin status (http status) : mã phản hồi
	- Thông tin body (nếu có) : data phản hồi, thông thường dưới dạng JSON

##II. Spring ResponseEntity##
Tài liệu: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html

- Kế thừa HttpEntity, với bổ sung http status

Minh họa một vài cách dùng thông dụng:
- trả về mình status
ResponseEntity.status(HttpStatus.Ok).body(null);

- trả về Status và headers:
ResponseEntity.status(HttpStatus.Ok).headers(Instance_of_HttpHeaders).build();

- trả về Status, headers và body:
ResponseEntity.status(HttpStatus.Ok).headers(Instance_of_HttpHeaders)
.body(Instance_of_object_send_back_to_client);

##II - HTTP Status Code hay dùng##
Tài liệu: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

Mã lỗi ám chỉ request thành công:
200 - request succeeded (hay dùng cho method GET/PUT/DELETE)
201 - request created a resource (hay dùng cho method POST)
204 - no content to return (dùng khi bạn muốn thông báo không có data ở phản hồi)

202 - Accepted (the request has been accepted for processing, but the processing has not been completed): dùng khi bạn chạy job/background task và muốn gửi phản hồi cho client

Mã lỗi ám chỉ request thất bại (lỗi do client):
400 - Bad request (lỗi exception, validate...)
401 - Unauthorized (unauthenticated): bạn chưa đăng nhập, có nghĩa rằng bạn cần login thành công thì mới có quyền sử dụng endpoint (API)
403 - Forbidden (unauthorized): bạn đã đăng nhập thành công, tuy nhiên, bạn không có quyền hạn (authorization) để thực hiện tác vụ này
404 - Resource not found : lỗi huyền thoại cmnr :v
405 - Method not supported : check cho đúng method khi sử dụng với endpoint

415 - Media not supported: bạn cần truyền đúng định dạng format mà server/client mong muốn. Ví dụ, bạn không thể dùng JSON để gửi file lên 
server (cần dùng formData)

Mã lỗi ám chỉ request thất bại (lỗi do server):
500 - Internal Server error: lỗi xảy ra bên trong Server, cần đọc logs để biết lỗi gì (exception, bugs...)
503 - Service Unavailable : server ngỏm (không chạy) nên không có sẵn để sử dụng
504 - Gateway Timeout : server (có thể) không ngỏm, cơ mà không phản hồi trong thời gian quy định (quá lâu để phản hồi)

1 - Update Status Code & Body cho APIs

- Đọc code: của class ResponseEntity -> là 1 class cần truyên vào thêm 1 đối tượng/generate (kiểu template trong C++) + keyword builder
- sử dụng ResponseEntity: đổi các kiểu dữ liệu trả về trong Controller = ResponseEntity<T> -> return về có 2 cách:
	+ new ResponseEntity<T>(body, header, status code)... (dùng constructor)
	+ hoặc dùng trực tiếp ResponseEntity.staticMethod (* dùng cách này) đây là 1 design pattern (builder pattern): Gọi trức tiếp đối tượng và sử dụng các static method -> được gợi ý + tên method có ý nghĩa  

	return ResponseEntity.status(HttpStatus.CREATED).body(null);
	Phần status có thể hash code 201 những nên dùng như trên ~ 201 nếu truy ngược lại 
	Phần body chỉ được truyền vào giá trị của đối tượng T
	Về phần headers -> đợi đến cookies 

return ResponseEntity.ok(user); sẽ tương đương với return ResponseEntity.status(HttpStatus.CREATED).body(user);
	-> hàm ok return về ok().body(T) (ok() -> HttpStatus.OK + body(T)) -> done

Đối với Delete -> nên trả ra status code là 204 - no content + nếu muốn ko trả ra đối tượng ở Body dùng ResponseEntity<Void>




Tài liệu: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html

//responseEntity<void> nếu set body = null

//lưu ý: endpoint nên viết số nhiều
Ví dụ => user => users

//update cho tất cả CRUD endpoint

2 - Giải thích code (Extra)

//tham khảo jhipster
https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/blob/master/src/main/java/com/mycompany/myapp/web/rest/DepartmentResource.java?ref_type=heads


//builder pattern là 1 design pattern 
https://springframework.guru/gang-of-four-design-patterns/builder-pattern/

====Chapter 6: Xử Lý Exception====

##I - Throw Exception##

https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/blob/master/src/main/java/com/mycompany/myapp/web/rest/DepartmentResource.java?ref_type=heads

//todo: // fetch user by id
Xử ký ngoại lệ khi người dùng gửi lên sai thông tin thay vì việc ném ra massage exception mặc định -> customize là 1 exception do mình tự định nghĩa ko dùng hàm có sẵn 
	- Tạo 1 class kế thừa lại Exception
	- Tạo 1 class kế thừa lại RuntimeException
Java có 2 loại Exception: checked Exception (lỗi dev pải handle: như người dùng truyền lên sai dữ liệu, ...) và unchecked Exception (null pointer exception)

Có 2 cách ném Exception: 
	ném exception ngay tại đầu hàm (khi truyền vào dữ liệu ko hợp lệ -> xử lý throw exception được) 
	try..catch (khi truyền vào dữ liệu ko hợp lệ -> ko xử lý throw exception được) -> throw exception mặc định
	-> 2 trường hợp này dùng với throw -> nó sẽ chỉ hiển thị lỗi ở Terminal ko hiển thị ra màn hình được -> cần sử dụng cái nào trả ra ResponseEntity(customize phần pản hồi ra client)

	@ExceptionHandler dùng để trang trí cho 1 hàm (như 1 listener) mỗi lần xảy ra ngoại lệ (khi throw ra exception nào mà exception đó được gán vào value của @ExceptionHandler) -> sẽ chạy vào hàm này + ResponseEntity để trả customized exception cho Client 
		@ExceptionHandler(value = IdInvalidException.class)		
		public ResponseEntity<String> handleIdException(IdInvalidException idInvalidException) {	
			return ResponseEntity.badRequest().body(idInvalidException.getMessage());
		}
	khi dùng dùng @Annotation này -> khi gặp lỗi cần throw trực tiếp thì nó mới chạy vào hàm xử lý của Annotation này - nếu dùng try..catch thì nó sẽ ko chạy vào
	Khi throw trực tiếp (ko dùn try..catch) thì đầu hàm phải có throws ...Exception nếu ko sẽ bị lỗi 

Tồn đọng: khi khai báo như trên bên trong UserController.java
(1) phạm vi hoạt động của function(@ExceptionHandler) chỉ nằm trong UserController -> cần định nghĩa khác để linh hoạt hơn
(2) hiện tại khi tham số truyền vào là 1 chuỗi String -> nó sẽ ko chạy vào throw bên trong hàm mà sẽ throw ở ngoài hàm = exception mặc định -> cần xử lý bên ngoài bắt ngoại lệ bên ngoài controller đó tức là bug ko nằm trong phần body hàm mà xảy ra lúc convert ở các tham số khi truyền vào của hàm
	Cách 1: valid ở frontend 
	Cách 2: chuyển kiểu dữ liệu thành String -> valid ở backend 

			Mô hình Spring Request Response 
client --request--> controller 
				----> local Exception (khai báo @ExceptionHandler bên trong 1 file java) --crash--> client
				----> globle Exception 
	local Exception -> chỉ dùng được trong 1 file 
	-> cần chuyển nó ra thành globle Exception để dùng trong nhiều trường hợp để làm thì ta có 1 khái niệm gọi là AOP là 1 khái niệm chia cắt ứng dụng thành các thành phần ko quan hệ với nhau (các thành phần độc lập)

Giới thiệu về AOP
https://docs.spring.io/spring-framework/reference/core/aop.html

Tham khảo: https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/tree/master/src/main/java/com/mycompany/myapp?ref_type=heads
-> trong github này họ làm cho logging aop/logging trong này họ dùng các Annotation rất đặc biệt như @Aspect, @PointCut, ... dự án này sẽ dùng ControllerAdvice là 1 ứng dụng của AOP để can thiệp vào quá trình xử lý trước khi trả về phản hồi cho người dùng + ko tập trung code tại 1 file mà nó sẽ chịu trách nhiệm tất cả các file còn lại 
				

Xử lý (1):  @ControllerAdvice

-  Spring @ControllerAdvice https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html

Được giới thiệu từ version Spring Framework 3.2
Xử lý @ExceptionHandler, @InitBinder, or @ModelAttribute được chia sẻ tại tất cả controller trong ứng dụng MVC
Cũng có thể làm tương tự cho RESTful, tuy nhiên cần @ResponseBody

@ResponseBody giúp convert Response trả về dưới dạng JSON
Ví dụ 1: Xử lý với MVC
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(value = Exception.class)
   public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {
        ModelAndView mav = new ModelAndView();
        mav.addObject("exception", e);
        mav.addObject("url", req.getRequestURL());
        mav.setViewName("error");
        return mav;
    }
}
-> cấu hình và response ra view cho người dùng

  Ví dụ 2: Xử lý với RESTful  
// Handle custom exceptions across the application
    @ExceptionHandler(CustomException.class)
    @ResponseBody //phần cần thêm để có thể sử dụng ResponseEntity<T> phía dưới nếu k có ko dùng được  
    public ResponseEntity<?> handleCustomException(CustomException ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
                HttpStatus.BAD_REQUEST.value(),
                ex.getMessage(),
                request.getDescription(false));
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

Có 1 cách nữa để sử dụng với RESTFul, là sử dụng  @RestControllerAdvice

@RestControllerAdvice được giới thiệu từ version 4.3

https://docs.spring.io/spring-framework/docs/4.3.9.RELEASE/javadoc-api/org/springframework/web/bind/annotation/RestControllerAdvice.html

So sánh @RestControllerAdvice và @ControllerAdvice: 
https://stackoverflow.com/a/43124517

@RestControllerAdvice = @ControllerAdvice + @ResponseBody

@ControllerAdvice dùng được cho Spring MVC + Restful API (kèm theo dùng @ResponseBody)
@RestControllerAdvice chỉ dùng cho Restful API (ra đời sau)
	
2 Annotation này sẽ can thiệp vào ném ra Exception @ExceptionHandler, khởi tạo giá trị @InitBinder, gán giá trị cho ModelAttribute @ModelAttribute -> can thiệp vào quá trình xử lý đây cũng là 1 Ứng dụng của AOP

##II - Format Response before Sending (Part 1)##

Tài liệu: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseBodyAdvice.html

1.Ví dụ về API trong thực tế

Việc viết API này -> phục vụ cho dự án + đối tác (đồng nhất theo 1 chuẩn)

https://developers.momo.vn/v2/#/docs/query_status

Một kết quả trả ra của API, luôn cần có:
Status code : 200, 201, …
Message : miêu tả nếu có
Data : nếu có

Mỗi 1 công ty có 1 quy định khác nhau về format của phản hồi, tuy nhiên, tối thiểu API cần cung cấp 3 thông tin trên

Mục tiêu: Trả về response theo format định sẵn
Trường hợp thành công:
{
  statusCode: " ", //200 404
  message: " ",
  data: " "
}

Ví dụ:
{
    "statusCode": 201,
    "message": "User Login",
    "data": {
        "access_token": "",
        "user": { }
    }
}

Trường hợp lỗi : 
{
    "message": " ",
    "error": " "
    "statusCode":" ",
}
Ví dụ: {
    "message": "Username/password không hợp lệ!",
    "error": "Unauthorized",
    "statusCode": 401
}


2.Format Response

Cách 1: sử dụng local với ResponseEntity -> gửi dữ liệu về client
https://stackoverflow.com/a/44840010
-> nhược điểm: ko linh động cần thêm thủ công -> có bao nhièu API pải thêm bấy nhiêu ResponseEntity

Cách 2: sử dụng global với Controller Advice
https://stackoverflow.com/a/52104852
-> linh động hơn ~ như xử lý Exception 

Bước 1: Định nghĩa format object

public class RestResponse<T> {
    private int statusCode;
    private String error;

    // message có thể là string, hoặc arrayList
    private Object message;
    private T data;

}


Bước 2: Sử dụng ControllerAdvice
https://stackoverflow.com/a/51551663

@ControllerAdvice
public class FormatRestResponse implements ResponseBodyAdvice<Object> {
	
//đây là 2 method buộc override của interface ResponseBodyAdvice
    @Override
    public boolean supports(
        MethodParameter returnType, 
        Class converterType
    ) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(
    Object body, 
    MethodParameter returnType, 
    MediaType selectedContentType,
    Class selectedConverterType,
    ServerHttpRequest request, 
    ServerHttpResponse response
) {
    
                // Check if the status code represents an error
        if (status >= 400) {
            //case error
        } else {
            //case success
        }
    }
}

- ở hàm supports có ý nghĩa cấu hình khi nào muốn ghi đè - khi nào format phản hồi của API 
	-> return về true bất cứ phản hồi nào cũng ghi đè
	-> sau này muốn check cho từng controller thì ghi logic vào đây
	
	-> return false thì nó sẽ ko format 

- hàm beforeBodyWrite được chạy khi hàm supports trả về true 
	Object body: là phản hồi chưa format
	request: lời gọi từ client -> server 
	response: thông tin trả về từ server -> client 
	-> muốn lấy trạng thái của pản hồi pải thông qua response
	
	Nhưng đối với response thông thường -> sẽ không lấy về được status code cần ép kiểu nó về HttpServletResponse 
	HttpServletResponse servletResponse = ((ServletServerHttpResponse)response).getServletResponse();

- cấu hình lại phần response:
	int status = servletResponse.getStatus();

        RestResponse<Object> restResponse = new RestResponse<Object>();
        restResponse.setStatusCode(status);
        if (status >= 400) {
            // case error
            restResponse.setError("CALL API FAIL");
            restResponse.setMessage(body);
        } else {
            // case success
            restResponse.setData(body);
            restResponse.setMessage("CALL API SUCCESS");
        }
        return restResponse;

Tới đây nếu test api truyền sai dữ liệu lên -> vẫn chưa hoạt động đúng vì nó sẽ chạy ResponseBodyAdvice<Object> trong FormatRestResponse.java trước khi chạy vào GlobalException.java có 2 cách để xử lý thứ tự:
	- dùng Annotation Order 

- Khi cấu hình xong class này thì mọi phản hồi từ Server -> Client để sẽ chạy vào đây chứ ko phải phần return của từng API nữa 

3 - Cấu hình Phần Globla Exception + Global Response: dùng @ControllerAdvice, @ResponseBody || @RestControllerAdvice
- Khi gọi API thành công -> chạy vào controller -> đến return ResponseEntity.status(HttpStatus.OK).body(this.userService.fetchUserById(id)); -> chạy sang FormatRestResponse(globla Response chạy qa 2 hàm supports -> beforeBodyWrite) -> response về cho client

- Khi gọi ko thành công -> chạy vào throw new IdInvalidException("user ko ton tai"); -> chạy vào class IdInvalidException -> chạy vào GlobalException.java -> FormatRestResponse (Global Response chạy qa 2 hàm supports -> beforeBodyWrite) -> response về cho client

** tất cả test cho API /users/{id} với kiểu kiểm tra đơn giản là id có tồn tại hay ko **

====Chapter 7: Spring Security với Json Web Token====
**Bảo vệ APIs với cơ chế JWT của mô hình Stateless

##I - Mô hình Stateful và Stateless##
Tương tự khi so sánh Monolithic và Microservice

1.Keyword hay gặp
Lưu ý 1: Không nên dịch nghĩa, thay vào đấy là nên “cảm nhận” ý nghĩa của nó.
Lưu ý 2: các dịch nghĩa bên dưới mang tính chất tương đối. Bạn có thể google để xem “cách định nghĩa” chính xác nhất.

Stateful = state application + full : chứa đầy state của application
Lưu trữ thông tin bên trong ứng dụng, ví dụ như thông tin người dùng đăng nhập
	Session : phiên đăng nhập. Được dùng trong mô hình Stateful, cách mà ứng dụng lưu trữ data giữa các lợi gọi request

Stateless = state application + less : không chứa state của application
Không lưu trữ thông tin trong ứng dụng (nothing at all)

Monolithic: (architecture) all-in-one : bạn code tất cả mọi thứ trong 1 dự án. Ví dụ như mô hình MVC truyền thống tự code controller, model, view, ... all things chỉ nằm trong 1 dự án java 

Microservice: (architecture): single-unit : bạn chia code thành các “thành phần riêng lẻ” (module/service), mục đích là giảm sự phụ thuộc giữa các thành phần, và tăng tính mở rộng


2. Stateful và Stateless

Stateful = Monolithic (Spring MVC)

Stateless = Microservice (Restful API)

Không có khái niệm Monolithic hay Microservice tốt hơn, cái nào cũng có ưu và nhược điểm của nó. Việc bạn cần làm, là lựa chọn công nghệ sao cho nó “phục vụ tốt với mục đích của bạn”

3.Tại sao chúng ta chọn Stateless thay vì Stateful (khóa MVC - Monolithic) ?

- Sử dụng RESTful API, thông thường (hay dùng nhất) là áp dụng cho mô hình Stateless.
- Có nghĩa rằng, bạn sẽ chia tách code thành Frontend và Backend riêng lẻ (không phụ thuộc vào công nghệ)

Ví dụ:
Frontend:  bạn code với Angular/Vue/React. 
Hoặc thậm chí chỉ là HTML, CSS, Javascript (AJAX)

Backend: sử dụng bất cứ ngôn ngữ backend nào bạn muốn, như Javascript, Java, PHP…
Javascript : Express, Nestjs…
Java: Java Spring
PHP: Laravel
C# : .Net
Python: Django
Ruby: Ruby on Rail …

- RESTful API là cầu nối giữa frontend và backend. Điều này lý giải:
	+ Frontend sẽ không thể thao tác với database (CRUD dữ liệu), mà cần làm gián tiếp qua API
	+ Backend sẽ không cần code giao diện, chỉ thực hiện nhiệm vụ thao tác với dữ liệu (lưu trong database) và tạo ra API cho frontend dùng. 
- Chúng ta đang làm nhiệm này (tạo ra RESTful API)

4. Cơ chế xác thực của Stateless
Trong mô hình Stateless, không tồn tại khái niệm “Session”, thay vào đấy là “Token”

- Cơ chế xác thực dựa vào Session (Stateful)
	Bước 1: login với username/password
		Nếu login thành công, server sẽ tạo lưu thông tin tại: Client thông qua cookies (lưu SESSION_ID)
		Server trong memory (RAM) hoặc database (lưu full thông tin của user login)

	Bước 2: Mỗi lần người dùng F5 (refresh) website gửi 1 request  từ client lên server, các bước làm tại Server:
		Client sẽ gửi kèm SESSION_ID (thông qua cookies)
		Server sẽ kiểm tra SESSION_ID có đang tồn tại hay không ? Nếu có, tiếp tục việc truy cập như thông thường (else, logout)

Mô hình Stateful với Session chỉ áp dụng hiệu quả, khi và chỉ khi bạn kiểm soát cả frontend và backend

Nhược điểm: chỉ giao tiếp giữa client và server -> nếu muốn viết ứng dụng cho mobile, desktop, đối tác, ... (server -> server) -> cần mô hình Stateless để giải quyết 

- Cơ chế xác thực dựa vào Token (Stateless)
với mô hình này t ko kiểm soát all thông tin 
Server với Server, mobile app, desktop app…  (những cái không có cookies)

Token: là 1 chuỗi ký tự đã được mã hóa (chỉ Server mới có thể hiểu) 
Ví dụ: adfasdfasdfasdfxyadfyajsdfasdfad
có 1 cơ chế sinh token: JSON Web Token

Bước 1: login với username/password
Nếu login thành công, server sẽ tạo token, lưu tại đâu, client tự quyết định.
Server không lưu bất cứ thông tin gì về việc user login 

Bước 2: Mỗi lần người dùng F5 (refresh) website gửi 1 request  từ client lên server, sẽ cần gửi kèm token đã có tại bước 1.
Server sẽ giải mã token để biết được user có hợp lệ hay không ?

##II - JSON Web Token (JWT)
Tài liệu:
https://jwt.io/

1.JWT là gì ?
https://jwt.io/introduction
- cho phép tạo 1 chuỗi kí tự ngẫu nhiên 
- Là một chuỗi ký tự được “mã hóa” (thông qua thuật toán) và có tính bảo mật cao.
- Được sử dụng để trao đổi thông tin giữa các hệ thống với nhau (server - server, client - server)

2. Cấu trúc của JWT
Gồm: 
	Header: quy định thông tin của token: thuật toán sử dụng, ...
	Payload (đây là cái chúng ta quan tâm nhất): data chứa trong token, thông tin định danh của người dùng (không có lưu mật khẩu)
	Signature: giúp tăng thêm độ mạnh mẽ, bảo mật của token như đặt mật khẩu để giải mã token 
ba thông tin này ngăn cách nhau bởi dấu chấm 

-> dùng đến Spring Security - cấu hình nó 
- ở Spring MVC để đăng nhập chúng ta cấu hình provider:
	+ DaoAuthenticationProvider
	+ third party thì dùng: OidcAuthenticationProvider, OAuth2AuthenticationProvider

đối với dự án này sẽ tìm hiểu về JwtAuthenticationProvider

##III - Cơ chế mặc định của Spring Security##

Tạo class config/ConfigConfiguration.java -> để biến class này thành cấu hình -> dùng Annotation Configuration dùng cái này khi ứng dụng chạy nó sẽ dùng component scan nó sẽ quét all component đối với component nào có Annotation Configuration nó sẽ đưa vào phần cấu hình việc code trong class có Annotation này sẽ ghi đè lại các cấu hình mặc định của Spring kế từ Version 5.8 sẽ dùng qa Bean chứ ko kế thừa các interface cần thiết

Ngoài Annotation configuration còn có EnableMethodSecurity: 
	có nhiều level để xác thực người dùng: mỗi 1 lần gửi request lên phía server -> cần xác thực hoặc xác thực tại lớp method 

đối với dự án ban đầu đã disable phần Security: ở file main
//disable security
@SpringBootApplication(exclude = {
		org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class,
		org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration.class
})
// @SpringBootApplication

1. Cấu hình Password Encoder: https://drive.google.com/file/d/1g8vEafVNLmO63V_2RrOmQQDTi8NMkMds/view
- ghi đè phần mã hóa password của Security
- để mã hóa mật khẩu của người dùng

//todo : hoàn thiện tính năng CREATE user với hash Password
passwordEncoder.encode()
admin@gmail.com abc
user@gmail.com abc
thtrong@gmail.com abc

2. Enable Security 
- vào file main file đầu tiên ứng dụng chạy lên
- comment cái disable security đi và enable cấu hình mặc định lên 
- sau khi enable nó lênn nó sẽ cấu hình mặc định rất nhiều lớp filter pải đi qa trước khi đến với các endpoint của controller 
(lúc này khi vào postman gửi request -> lỗi 401 unauthorized)
- mặc định nó đã bảo vệ all endpoint, tài nguyên nếu muốn truy cập -> cần đăng nhập 
- lúc này khi truy cập ứng dụng qa browser -> thì sẽ bị văng về trang login (dùng cho mô hình MVC stateful) nhưng đối với ứng dụng này dùng mô hình stateless tức là dùng JWT để truy cập -> ko cần form login này 

- tiếp theo cần cấu hình thêm phần security để có thể truy cập vào được một số url: cấu hình http cần ghi đè lại 1 phần cấu hình tên là SecurityFilterChain 
	+ những API gửi lên server thực tế là 1 lời gọi của http -> cần cấu hình http.authorizeHttpRequests
		đầu tiên enable session lên: 
		.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
		bởi vì mặc định spring Security theo mô hình STATEFUL -> trong pần session pải cấu hình lại STATELESS
	+ phần cấu hình mặc định hiển thị ra trang login, hay đăng nhập = basic form, truy cập mọi endpoint pải cần xác thực ... nằm ở class SpringBootWebSecurityConfiguration.class nhưng trong ứng dụng này dùng JWT -> override lại 

##IV - OAuth Flow##

hiểu tổng quan để tự viết một vài Filter -> để khi client gửi request lên server pải đi qa filter này nhiệm vụ của filter này sẽ giải mã token mà client gửi lên 
chức năng của filter: 
	lấy JWT token từ header mà người dùng gửi lên 
	load user lên -> ghi đè lại pần này 
	cần validate token (viết thêm 1 service để giải mã/validate, mã hóa, tạo,... token)
	cuối cùng nạp vào SecurityContextHolder 

1. Lưu ý về cách code JWT với Spring

KHÔNG LÀM NHƯ CÁC VÍ DỤ BÊN DƯỚI: ĐÂY LÀ CÁCH CODE CHO CHẠY ĐƯỢC, KHÔNG PHẢI LÀ CÁCH CÔNG TY LÀM, VÌ NÓ TIỀM ẨN RỦI RO VỀ SECURITY

https://www.geeksforgeeks.org/spring-boot-3-0-jwt-authentication-with-spring-security-using-mysql-database/

https://www.youtube.com/watch?v=KxqlJblhzfI

Giải thích quy trình code cho chạy được:

Bước 1: Cài đặt các thư viện hỗ trợ JWT (encode/decode)
Bước 2: Viết Filter (tạm gọi là jwtFilter) để xử lý cho JWT
Filter này sẽ được chạy trước khi Spring Security xử lý (chạy các Filter khác)

jwtFilter sẽ có nhiệm vụ decode/verify (giải mã và xác thực tính hợp lệ) của JWT mà client truyền lên

2. OAuth là gì ?

Để mở rộng mô hình và chuyển sang mô hình kiểu service (các client, server, service,... có thể kết nối/sử dụng dịch vụ được) -> Spring sử dụng giải páp sử dụng tiêu chuẩn OAuth (open auhthorization) 

OAuth (open auhthorization) tức là việc xác thực người dùng ntn, người dùng có quyền hạn ntn sử dụng rộng rãi trong mô hình Microservice 

Tham khảo: 
https://www.youtube.com/watch?v=ZV5yTm4pT8g
https://www.youtube.com/watch?v=ZDuRmhLSLOY

OAuth (Open Authorization) là một chuẩn (standard) dùng để xác thực thông tin người dùng thông qua token. (từ 2012)
Tham khảo (v2.0): https://datatracker.ietf.org/doc/html/rfc6749

Được ứng dụng rộng rãi trong mô hình stateless (microservice) khi một ứng dụng liên quan tới nhiều dịch vụ (service)

Các vai trò (role) khi sử dụng OAuth:
Resource Owner : người sử hữu nguồn tài nguyên, thông thường chính là User - người sở hữu tài khoản của họ.  Ví dụ, bạn là chủ sở hữu của tài khoản Facebook do bạn tạo ra

Resource Server: nơi hosting dữ liệu của người dùng. Ví dụ, tài khoản Facebook của bạn sẽ được lưu trữ tại server nào đó do Facebook Quản lý

Client: Ứng dụng muốn truy cập/sử dụng thông tin của người dùng

Authorization Server: nơi chịu trách nhiệm tạo ra access-token để cho Client sử dụng Resource Server (sau khi đã được Resource Owner cho phép)

Ví dụ:
https://www.codeproject.com/Articles/1171546/OAuth-Authorization-flows-explained-with-examples
như vào github thực hiện chức năng đăng nhập với Google: 
	Resource Owner là người dùng người sở hữu tài khoản Google là người có quyền cấp phép 
	Resource Server là server của Google
	Client: là trang Github
	Authorization Server nó là của Google bởi vì chỉ có Google mới biết thông tin tài khoản đăng nhập được nhập vào có đúng hay không -> khi bấm vào đăng nhập thì quá trình Authorization nó sẽ xảy ra tại Google tại Authorization Server nó sẽ kiểm tra và nếu đúng nó sẽ trả lại thông tin cho Client(Github) như AccessToken 
	khi có AccessToken Client sẽ Query trực tiếp đến Resource Server để lấy tài nguyên

##V -  Spring và OAuth##
Hướng dẫn tích hợp OAuth

1. Lịch sử ra đời và sử dụng với Spring

Spring là 1 Hệ Sinh thái (Frame Work): Spring Security nếu nói ở trong Frame Work Spring thì là thư viện nhưng với mô hình của nó có thể nói nó là 1 Frame work khác

- Trước 2022: Spring Security OAuth
https://spring.io/blog/2022/06/01/spring-security-oauth-reaches-end-of-life
dự án này end of life: ko được pát triển nữa -> đưa ra 2 sự lựa chọn 
	+ sử dụng tính năng có sẵn của Spring Security(OAuth 2.0) ra đời khi vừa có Spring Security về ưu điểm là đã tích hợp sẵn trong Spring Security -> ko cần cài thêm gì và có thể giải quyết vấn đề, nhược khó bảo trì vì nó liên quan qá nhiều tới Spring từ trước đến nay -> ko thể linh hoạt khó thay đổi chỉnh sửa nhiều (theo mô hình Statefule)
	-> nếu mún sử dụg với nhu cầu nhỏ, ko thay đổi nhiều nên sử dụng của Spring Security
	Đối với ứng dụng này sẽ dùng cái này chứ ko dùng cái mới 

	+ sử dụng dự án Spring Authorization Server (1 thư viện/Frame work khác của Spring) cái này là cái cập nhật cho công nghệ OAuth2 mới nhất (OAuth 2.1) ra đời năm 2022 ưu điểm ko phụ thuộc vào cái gì cả và luôn cập nhật cái mới nhất (theo mô hình Stateless đang tách riêng ra) -> ko dính nhiều tới các dự án Spring khác -> có thể thay đổi linh hoạt 
	-> nếu mún controll hết, thay đổi linh hoạt, update nhanh mới nên dùng thư viện/frame work mới này 

2 cái này chính là tác nhân Authorization Server trong mô hình OAuth2 

https://github.com/spring-attic/spring-security-oauth
dự án này đag ở trạng thái publish archive: là trạng thái hoàn thành rồi + ko được bảo trì nữa -> nếu có bugs hoặc công ngệ mới sẽ ko được cập nhật 
-> cân nhắc khi sử dụng 

- Sau 2022 : có 2 dự án (project) nổi bật hỗ trợ OAuth là:
Spring Security (hỗ trợ OAuth 2.0) là 1 tính năng tích hợp sẵn 
https://docs.spring.io/spring-security/reference/6.1/servlet/oauth2/index.html
Khi làm Spring MVC vào link này chỉ đụng tới Authentication + Authorization chứ chưa đụng vào package OAuth2 -> đây sẽ là pần làm trong ứng dụng này (nằm trong Spring Security) trong package này sẽ sử dụng OAuth2 Resource Server bởi vì hiện tại ứng dụng sẽ xác thực người dùng + tạo token nên pải dùng pần này, ko sử dụng OAuth2 Client vì cần request tới 1 nơi nào đó để lấy token trong khi ứng dụng tự tạo token chứ ko lấy từ Client nào (nếu muốn làm thủ công pải + 1 dự án java nữa để làm pần này), nếu muốn làm login cho gg hoặc face -> cần code 1 ứng dụng giúp Authorization cho 2 app 

https://github.com/spring-projects/spring-security


Spring Authorization Server (hỗ trợ OAuth 2.1): đây cũng là 1 dự án khác Spring Security tạo ra để bảo vệ Endpoint (cùng cấp với Spring Security)
https://spring.io/projects/spring-authorization-server
https://github.com/spring-projects/spring-authorization-server

Spring Security: 
	Gắn liền với hệ sinh thái của Spring, gần như là default (cấu hình mặc định) khi liên quan tới việc Authentication/Authorization
	Một sự thay đổi nhỏ thôi, cũng có thể là breaking-change, khi có quá nhiều ứng dụng phụ thuộc vào nó. Cơ mà, tích hợp luôn OAuth thì quá tuyệt vời (all-in-one)

Spring Authorization Server: 
	Ra đời muộn hơn Spring Security (2022) : https://spring.io/blog/2022/11/22/spring-authorization-server-1-0-is-now-ga
	Up to date với Security, có nghĩa là cập nhật những cái mới nhất, ví dụ OAuth 2.1
	Là một dự án độc lập (base dự trên Spring Security)


2. Mô hình áp dụng
https://docs.spring.io/spring-security/reference/servlet/oauth2/index.html#oauth2-resource-server

- Cài đặt dependencies:
implementation("org.springframework.boot:spring-boot-starter-oauth2-resource-server")
Fix lỗi không cài đặt dependency:
Bước 1: thêm dependency vào file build của gradle (lưu ý là trong video mình có yêu cầu thay đổi, vì lúc quay video mình có bug)
	implementation("org.springframework.boot:spring-boot-starter-oauth2-resource-server")
Bước 2: nhấn chuột phải vào file build.gradle.kts => chọn Reload Projects

- Với OAuth2, chúng ta cần:
	Auth Server (Authentication/Authorization): nơi xác định người dùng có tồn tại hay không  ? Nếu có,  người dùng có quyền hạn gì sau khi đã xác thực/đăng nhập thành công)
	Resource Server : nơi chứa nguyền tài nguyên (data) mà người dùng muốn truy cập

Áp dụng vào bài toán của chúng ta: (cách làm đơn giản nhất)

Client : React

Server : Java Spring (chỉ có 1 server) - all in one
=> server này cần làm các nhiệm sau: (nơi cung cấp tài nguyên, tạo token, xác thực người dùng luôn)
	Xác thực người dùng (authentication): chức năng login. 
	Xác định quyền hạn của người dùng (authorization) : permission và role
	Sau khi đã xác thực và đảm bảo người dùng “phù hợp”, server cho phép client truy cập nguồn tài nguyên (thông qua api)

##VI - Login Flow##
1.Mô hình MVC
https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html

Mô hình chung: khi login nó sẽ chạy qa các filter chains kế thừa lại abstract AbstractAuthenticationProcessingFilter -> authentication -> authenticationManager (ở đây nó sẽ check dùng cơ chế gì để đăng nhập + authenticated ? thông tin đăng nhập):
	+ nếu đúng -> SessionAuthenticationStrateyg + SecurityContextHolder(*) + RememberMeServices + ApplicationEventPublisher + AuthenticationSuccessHandler (chủ yếu là lưu thông tin vào * để mình xử lý)
	+ nếu sai -> SecurityContextHolder + RememberMeServices + Authentication (ném ra exception)


- đối với ứng dụng này:
Khi bạn nhấn nút login, sẽ gửi request lên server và trigger filter.
khi đăng nhập = username + password -> Filter được gọi ở đây là UserNamePasswordAuthenticationFilter trong này lần lượt gọi tới: 	
	UsernamePasswordAuthenticationToken(1)
	AuthenticationManager - pần này nó sẽ là phần gọi authenticate() (2)
		ProviderManager
		DaoAuthenticationProvider(Provider xử lý trường hợp đăng nhập = username và password) đối với Provider này có function: UserDetails loadUserByUsername(String username)

	-> success -> tương tự như mô hình chung là lưu thông tin vào SecurityContextHolder 
	-> Fail -> throw exception

Ở đây có 1 vấn đề: đối với mô hình stateless ko hề có form login khi đăng nhập -> k thể trigger phần Security được bởi vì ko có function nào gọi trực tiếp đến UserNamePasswordAuthenticationFilter -> thay vì vậy t sẽ tự tạo chay từng thành pần:
	(1) -> tự tạo token 
	(2) -> tự gọi đến phần AuthenticationManager -> gọi hàm authenticate() 
	-> đăng nhập success -> tự lưu thông tin vào SecurityContext 


2. Đối với Mô Hình Stateless - các bước thực hiện vấn đề trên
Bạn không có form login để trigger filter, thay vào đấy là API endpoint.
Bước 1: bạn submit api với username/password

Bước 2: Spring sẽ không trigger Filter nào hết, mà sẽ chạy thẳng vào controller, nơi bạn định nghĩa endpoint (vì cơ chế JWT là cơ chế không được xây dựng sẵn của Spring)

=> chúng ta cần viết logic để xử lý đăng nhập người dùng (kế thừa tương tự logic của UserNamePasswordAuthenticationFilter )
Why ?
Vì khi làm theo luồng của Spring Security, chúng không cần bận tâm về quá trình so sánh mật khẩu user và nạp thông tin user vào Security Context (đế tái sử dụng - tương tự như Session)

//tạo token với username và password được nạp lên từ client 
 UsernamePasswordAuthenticationToken authenticationToken 
= new UsernamePasswordAuthenticationToken(username, password) 

//truyền token vào authenticationManagerBuilder (chính là bước ở AuthenticationManager)
//authenticate() -> xác thực password và username gửi lên có đúng hay ko gián tiếp thông qa token
Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);

//-> sau khi ở AuthenticationManager -> cần authenticated -> gọi đến UserDetails LoadUserByUserName(String username) -> cần override lại: ở đây sẽ giải mã token -> lấy user từ database lên so sánh 

//nạp thông tin (nếu xử lý thành công) vào SecurityContext để tái sử dụng thông tin của người dùng giữa các lời gọi request ở mô hình stateless ko sử dụng session -> bây h muốn từ controller gọi đến services -> bên trong services cần lấy thông tin của người dùng thì sẽ lấy từ SecurityContext này 
 SecurityContextHolder.getContext().setAuthentication(authentication);
 String jwt = this.createToken(authentication);

Tham khảo: https://drive.google.com/file/d/1Goo_ejUCnyahSGpxTTp4S0yKt5oQdhhM/view

##VII - loadUserByUsername##

ở đây chỉ mới xác thực thông tin người dùng xem thông tin đăng nhập có hợp lệ ko chưa hề đụng tới token 



Bước 1: Tạo DTO class 
username: String
password: String

Bước 2: tạo AuthController 
	disable formlogin mặc định của Security
	disable cơ chế csrf -> nếu ko khi dùng endpoint dạng login method post sẽ lỗi 403 + với mô hình stateless cũng ko dùng token này 
Tạo endpoint: /login

//Nạp input gồm username/password vào Security
 UsernamePasswordAuthenticationToken authenticationToken 
= new UsernamePasswordAuthenticationToken(username, password)

//xác thực người dùng => cần viết hàm loadUserByUsername
Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);
	với authenticationManagerBuilder được tiêm vào và lệnh này nếu để pure như này sẽ bị lỗi -> cần hiểu cơ chế của Spring Security nó xác thực người dùng ntn mặc định nó sẽ lưu người dùng vào Memory chứ k biết mình lưu người dùng vào Database (Memory chỉ có 1 trên máy người dùng, SQL có nhiều loại -> cần nói cho nó biết lưu ntn ở đâu) -> cần viết lại hàm loadUserByUserName trong này 

//nạp thông tin (nếu xử lý thành công) vào SecurityContext
 SecurityContextHolder.getContext().setAuthentication(authentication);

Bước 3: Viết Service UserDetail loadUserByUsername(String username) 

tạo class UserDetailsCustom implements UserDetailsService trong interface UserDetailsService chỉ có 1 hàm loadUserByUsername(String username) với username chính là username gửi từ client lên dùng để query user sau khi lấy được user từ database -> hash password gửi từ client so sánh với password đã hash từ user vừa lấy lên từ database (quá trình so sánh này sẽ được spring tự động làm) nhiệm vụ cần làm:
	tìm người dùng bên tron database -> truyền password hash từ người dùng này vào cho spring 

- để cho Spring biết được mình đag viết class UserDetailsCustom ghi đè lại UserDetailsService: 
	+ đối với mô hình MVC cần cấu hình lại config/SecurityConfiguration.java: ghi đè nạp nó nào 
	+ Nhưng đối với ứng dụng này t sẽ làm level cao hơn = cách ghi đè = tên của @Bean cơ chế: mặc định nếu ko định nghĩa tên của Bean -> nó sẽ dùng tên của kiểu trả về của function bên dưới các @Bean -> convert tên đối tượng đó mặc định nó sẽ biến chữ tiên thành chữ thường đây là quy tắt đặt tên Bean của Spring sẽ lấy tên đối tượng đã được chuyển đối -> làm tên của Bean đó
	-> thay vì việc cấu hình trực tiếp thì mình sẽ cấu hình gián tiếp thông qua tên của Bean 
	-> ko cần cấu hình bên trong config/SecurityConfiguration.java mà chỉ cần thêm @component("userDetailServices") vào trc class UserDetailsCustom 

//lưu ý: xử lý custom exception (nếu sai mật khẩu/email) 
Tham khảo https://www.google.com/url?q=https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/blame/master/src/main/java/com/mycompany/myapp/security/DomainUserDetailsService.java?ref_type%3Dheads%23L20&sa=D&source=docs&ust=1739851688233574&usg=AOvVaw3SBTxMcTlrA3I_OlLPKUot

Về cách đặt Bean Name:
https://stackoverflow.com/a/53758500

nhiệm vụ cuối cùng là trả ra UserDetails theo đúng kiểu trả về của function loadUserByUsername(String username) -> giống Spring MVC sẽ dựa vào tính đa hình của Spring -> sẽ return về User của Spring Security vì class này có implements UserDetails
        return new User(
                user.getEmail(),
                user.getPassword(),
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));

##VIII -  Debug Code (Extra)##
1.Xử lý Exception
Validate dữ liệu username/password (không được để trống)

Validate trường hợp username/password đã truyền lên, nhưng không hợp lệ, bao gồm email không tồn tại/hợp lệ và sai password

Advance: handle tất cả exceptions, tham khảo https://drive.google.com/file/d/1j5IikoDtR9de0Mw-1QkH41_gCMCZ62FJ/view

//hiện tại, chưa xử lý exception của security (sẽ được xử lý cùng với việc validate jwt)
https://www.baeldung.com/spring-security-exceptionhandler

2.Luồng Debug

Kỹ năng debug: https://code.visualstudio.com/docs/editor/debugging

Debug từ ban đầu: khi dùng postman gửi request -> api: /login 
- đặt debug và dừng tại: UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
                loginDTO.getUsername(), loginDTO.getPassword()); trong controller url: /login 
	Step into: chạy vào loginDTO getUsername(), getPassword() -> chạy đến hàm tạo UsernamePasswordAuthenticationToken() -> gọi đến super() cha của nó AbstractAuthenticationToken .... sau khi xử lý xong phần cha -> qay lại gán giá trị principal = username, credentials = password... trong hàm khởi tạo sau đó qay về lại controller /login chạy đến lệnh kế tiếp trong controller

- tiếp theo đặt debug và dừng tại: Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken); dùng step into đầu tiên chạy vào pần xử lý của .getObject()... sau đó chạy vào authenticate() -> chạy vào hàm authenticate() của ProviderManager (thực chất hàm authenticate() này là của interface authenticationManager mà class ProviderManager kế thừa lại và được thực thi lúc này) trong hàm authenticate() này nó sẽ chạy vào vòng lặp để chọn ra Provider thích hợp đối với dự án hiện tại size của vòng lặp = 1 tức là chỉ có 1 Provider được xét vì đăng nhập = username và password chính là DaoAuthenticationProvider nếu bên trong phần config/SecurityConfiguration.java có cấu hình thêm phần đăng nhập khác (như đăng nhập dùng third party) thì size sẽ tăng lên và số lượng provider được cung cấp để scan cũng nhiều lên hiện tại chỉ cấu hình đơn giản/mặc định là đn = username, password... cứ step into sẽ tới 1 bước nó xử lý phần token mình gửi vào hàm authenticate() lấy ra principal(email) thông qua hàm getPricipal() của class UsernamePasswordAuthenticationToken ...

- tới bước trên cứ step into cho nó xử lý việc lấy và kiểm tra principal cuối cùng nó sẽ chạy vào function retrieveUser() bên trong DaoAuthenticationProvider trong này nó có kiểm tra việc hash password = cách nào (hiển thị cấu hình bên trong /config/SecurityConfiguration) cứ step into có phần hash phần password gửi từ client vào ... chạy các kiểu trong hàm retrieveUser() đến UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); username lúc này chính là email từ client gửi lên -> khi step into nó sẽ chạy vào loadUserByUsername(username) cái mà mình đã customize UserDetailsCustom là cấu hình để nó ghi đè lại cái mặc định, cứ step into cho đến return -> nó sẽ chạy lấy các thông tin sau đó vào hàm construct tạo ra User của Security cuối cùng là check các trường như accountNonExpired, accountNonLocked, credentialsNonExpired,... nhưng hiện tại khi khởi tạo mặc định nó sẽ = true hết nên sẽ pass khi check ...

- cuối cùng nó sẽ thực hiện xong function authenticate() -> trả giá trị về và qay lại controller (url: /login) và return ra ResponseEntity kết thúc 

Lưu ý: hiện tại luồng này chưa có nạp thông tin vào SecurityContextHolder

AuthenticationManager

ProviderManager (hàm authenticate)

=> quét ra DaoAuthenticationProvider

UserDetail

3. thực hiện bắt các Exception:
- khi người dùng nhập sai thông tin tài khoản hoặc ko nhập có điều chỉnh code
- ý tưởng sẽ xuất phát từ controller (tức là khi request gửi lên đã qua các filter vào được controller -> nếu có bất kì lỗi gì đều có thể bắt được - một số lỗi chưa tới controller nó đã bị -> chưa bắt được ở hiện tại)
- ở đây sẽ Validate thông tin gửi lên vào LoginDTO -> dùng @Valid để validate trực tiếp ngay bên trong model để dùng được nó thì cần cài dependency:
	implementation("org.springframework.boot:spring-boot-starter-validation")
- cách sử dụng: all annotation validate đều nhờ cài dependency package(jakarta.validation...)
	+ chỉnh lại đầu vào của controller thêm @Valid trước tham số cần kiểm tra: public ResponseEntity<LoginDTO> login(@Valid @RequestBody LoginDTO loginDTO)
	+ cấu hình cách validate trong model LoginDTO:
	@NotBlank(message = "username can't be blank")
    	private String username;

	@NotBlank(message = "password can't be blank")
    	private String password;
- khi làm đến đây -> khi chạy gửi lên thông tin lỗi nó vẫn sẽ gửi Exception mặc định của Security chỉ cấu hình sơ defaultMessage chính là cái message mình valid trong model 

- đọc phần trace của lỗi trên postman thì thấy bị exception: MethodArgumentNotValidException được ném ra -> cần cấu hình lại cái này cấu hình bên trong GlobalException.class:
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<RestResponse<Object>> validationError(MethodArgumentNotValidException ex) {
        BindingResult result = ex.getBindingResult();//dùng BindingResult để lấy ra message lỗi 
        final List<FieldError> fieldErrors = result.getFieldErrors();

        RestResponse<Object> res = new RestResponse<>();
        res.setStatusCode(HttpStatus.BAD_REQUEST.value());
        res.setError(ex.getBody().getDetail());
	// 3 dòng này để set các thông tin mặc định

        List<String> errors = fieldErrors.stream().map(f -> f.getDefaultMessage()).collect(Collectors.toList());
	//từ dạng list chuyển sang dạng stream thì mới dùng lamda được lấy ra all message sau đó convert người lại dạng List dùng collect gán nó lại vào 1 array String 
        res.setMessage(errors.size() > 1 ? errors : errors.get(0));
	//gán array lỗi nếu có hơn 1 lỗi thì gán nguyên array vào, ngược lại chỉ gán 1 chuỗi string 

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(res);
    }

- khi làm tới đây nếu trường hợp 1 trong 2 hoặc cả 2 username, password khi gửi request ko điền thông tin -> sẽ bắt được và xử lý lỗi 

- trường hợp ko bắt được: nếu nhập thông tin của username hoặc password sai -> sẽ throw ra exception BadCredentialsException mặc định ko bắt được vì nó lỗi trước khi mặc dù trong GlobalException.class có cấu hình bắt exception này -> nó chưa chạy vào đây nó đã bị lỗi 

- sẽ xử lý sau (thực tế có 1 số cách bắt all exception)

- cơ chế hoạt động: khi gửi request điền thiếu thông tin -> chưa chạy vào bên trong controller mà nó bắt ở @Valid throw ra Exception MethodArgumentNotValidException -> chạy thẳng đến GlobalException.class ResponseEntity<RestResponse<Object>> validationError để xử lý khi đến return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(res); -> sẽ chạy qa FormatRestResponse pần đã cấu hình để format ResponseEntity -> gửi Response ra client 

##IX - Cơ chế tạo JWT Token

1.Cài đặt thư viện
Chúng ta đã cài đặt: implementation("org.springframework.boot:spring-boot-starter-oauth2-resource-server") Công cụ trên đã hỗ trợ đủ cơ chế encode/decode JWT (mà không cần cài đặt thêm gì hết)  trong thư viện này đã cung cấp sẵn package com.nimbusds:nimbus-jose-jwt giúp mã hóa và giải mã JWT 

các package có sẵn trong thư viện đã cài: https://github.com/spring-projects/spring-security/blob/main/oauth2/oauth2-jose/spring-security-oauth2-jose.gradle

api 'com.nimbusds:nimbus-jose-jwt'

=> thư viện cần học cách sử dụng là: nimbus-jose-jwt
https://connect2id.com/products/nimbus-jose-jwt

2. Cách thuật ngữ hay dùng
JOSE: JSON Object Signing and Encryption

JWS: JSON Web Signatures  (quá trình validate data - client gửi data lên server, server cần validate)

JWE: JSON Web Encryption (quá trình mã hóa data - trước khi gửi data về cho client, server cần mã hóa)

JWK: JSON Web Key

JWA: JSON Web Algorithms

HMAC : Hash-based Message Authentication Code (sử dụng SHA, key secret và message để hash tạo ra output)

Về JWT, tham khảo ebook https://drive.google.com/file/d/1EHvJAkEg_Yiym5OECArnAq-rQeIXPUFC/view

3. Cơ chế tạo ra JWT
JWT được cấu tạo từ 3 thành phần: header.payload.signature

header (thông tin về thuật toán có 2 loại hay dùng: hash message, public & private key như RSA) => encode dưới dạng base64

payload (thông tin data chứa trong token) => encode dưới dạng base64

Signature (chữ ký) => được tạo nên từ thuật toán mã hóa + (header + payload) + key (mật khẩu) dưới dạng base64

Như vậy, signature gồm 3 thành phần: thuật toán mã hóa , data của (header + payload) và key (có thể là mật khẩu/ hoặc sử dụng private/public key)

Ví dụ mô hình: 
header{"alg":"HS256"} -> Base64 Encode -> "chuỗi header"
payload{"sub":"user-id-287873"} -> Base64 Encode -> "chuỗi payload"

data cần mã hóa = "chuỗi header"."chuỗi payload"

để xác thực token:
	key + thuật toán được quy định ở header + data cần mã hóa 
	-> 3 yếu tố này sẽ sinh ra chữ kí 
	tiếp tục chữ kí này sẽ được mã hóa lần nữa = Base64 -> "chuỗi chữ kí"

-> JWToken = "chuỗi header"."chuỗi payload"."chuỗi chữ kí"


Header ghi thông tin thuật toán HS256 sẽ được mã hóa = Base64 (một cơ chế chuyển đổi ngôn ngữ giúp máy có thể hiểu)
payload chứa thông tin data muốn lưu vào token sẽ được mã hóa = Base64 
-> nối 2 chuỗi lại để tạo token 
cuối cùng để xác thực token đó có hợp lệ hay ko (do server sinh ra hay do bên khác tạo fake) có 2 cách làm:
	- chia sẽ mật khẩu (Shared secret)
	- public & private key 
	(tạm thời chung quy 2 cái này là key) 

có 2 cách phổ biến
a shared secret (hs256) (cách dùng trong khóa học này)

a private/public key pair (rs256)

##X - Tạo Key (Part 1)#

Signature (chữ ký) => được tạo nên từ thuật toán mã hóa + (header + payload) + key (mật khẩu) dưới dạng base64

1. JWK (Json Web Key)
Key được tạo ra với một mục đích, cho dù JWT bị lộ ra, nếu không có “key”, bạn không thể giải mã được token
Có 2 hình thức tạo key phổ biến: một là dùng mật khẩu (hash) và hai là dùng public/private key

Với mô hình public/private key pair: (thuật toán RSA)
Ví dụ bạn dùng JWT để giao tiếp giữa Server A (chủ)  và Server B (khách)
	Server A sẽ giữ private key
	Server B chỉ được phép giữ public key. Và dùng public key này để giải mã (decrypt) token được A cung cấp. Với public key, B không thể “tự tạo được token”
-> dùng cho mô hình lớn dễ mở rộng

Với mô hình dùng mật khẩu (hash):
Ví dụ bạn dùng JWT để giao tiếp giữa Server A (chủ)  và Server B (khách)
	Server A sẽ giữ mật khẩu (key) 
	Server B cũng cần biết mật khẩu trên (shared key) . Và  key này để giải mã (decrypt) token được A cung cấp. B có thể “tự tạo được token”
-> dùng cho mô hình nhỏ khó mở rộng


2. Tạo Key

Bước 1: cấu hình .env variable (biến môi trường)
(sử dụng yaml)
security:
    authentication:
      jwt:
        # This token must be encoded using Base64 and be at least 256 bits long 
(you can type `openssl rand -base64 64` on your command line to generate a 512 bits one)
        base64-secret: ODcxODJlOGI4YTdhZWNlYzE4NmRhNzQwYzQ4ZmIxOTQzODMzZDcxOWQ2OGVlNTk5MjY0MTcxNTc3YTcyZmIzN2I0YmI4NmI1ZDU2NDU4YzUxZjI0MDMwM2E5MDI4YWU5YTIyMWQ5ZDNhODBhMmNhZjFkM2VlZWRhN2Y4ZWVlOTk=

(sử dụng .properties)
//update file application.properties
Lưu ý: ae copy paste thì cần để giá trị trên cùng 1 dòng (làm giống hệt như video), còn trong tài liệu là nó tự động xuống dòng. File application.properties tính cả dấu cách, dấu enter xuống dòng đấy

hoidanit.jwt.base64-secret=qoAEABDke07+AVLepXB4aCMtsT0wMAqR5x2VFyldsnx6e75YQkJH2UcZKTjEyoNgG71SBCXfq5N6NVZxWOfsHQ==
hoidanit.jwt.token-validity-in-seconds=86400//thời hạn hết hạn của key 

2 phần config này do ta tự định nghĩa (từ tên biến + giá trị) -> Spring sẽ ko hiểu cần cấu hình thêm 1 thư viện nó mới biết được (cũng ko cần thiết lắm) đơn giản chỉ khai báo 1 thuộc tính trong này và lấy ra dùng 

việc tạo key/giá trị của biến này hoidanit.jwt.base64-secret có thể là 1 chuỗi String bất kì, nếu muốn tăg tíh bảo mật -> dùng câu lệnh openssl rand -base64 64 (nếu dùng trog cmd của Mac/Linux thì mặc định dùng được, Windows pải cài thêm openssl) có thể dùng trong Git Bash (câu lệnh giúp random key dưới định dạng Base64

key mới tự sinh ra: tKqQcDw3NbLdtNRCbFRvwBQgb9RW/zlDuSkSHV5pHNozCIUZtt1fHHSEqaj16hvAXQbxN0krfrXv1VE6hTPyhw==

Bước 2: Sử dụng .env 
theo mô hình Dependency Injection với annotation 
@Value("${hoidanit.jwt.base64-secret}")
private String jwtKey;
https://stackoverflow.com/a/30528430

Bước 3: Tạo key
tạo thêm 1 service util/SecurityUtil.java:
	class này sẽ giúp tạo Token: gửi authentication (payload) qa đây để tạo token trong đó ko hề có mật khẩu (mặc định Spring Security ko lưu mật khẩu trong này)


sau khi lấy xog biến môi trường: 
	+ thuật toán: kéo từ package bên dưới về 
	+ package com.nimbusds:nimbus-jose-jwt

Viết cấu hình lại config/SecurityConfiguration.java :

	chúng ta dùng cách shared SecretKey chứ ko dùng Public&Private key -> cần lấy ra Secret key = cách giải mã key đã cấu hình trong .properties và giải mã dưới dạng byte -> sau khi có key cần tạo ra đối tượng SecretKey để return về 
	Base64 pải import từ Jose
	SecretKey này chính là cái để giúp cho việc khai báo và mã hóa/encoder Token -> thêm phần @Bean cấu hình lại giống như phần passwordEncoder 


//update file security config:

 public static final MacAlgorithm JWT_ALGORITHM = MacAlgorithm.HS512;

  private SecretKey getSecretKey() {
        byte[] keyBytes = Base64.from(jwtKey).decode();
        return new SecretKeySpec(keyBytes, 0, keyBytes.length, JWT_ALGORITHM.getName());
  }

 
@Bean
public JwtEncoder jwtEncoder() {
        return new NimbusJwtEncoder(new ImmutableSecret<>(getSecretKey()));
}

Tham khảo https://drive.google.com/file/d/1Goo_ejUCnyahSGpxTTp4S0yKt5oQdhhM/view


Bước 4: Tạo Access Token (JWT)

    public String createToken(Authentication authentication) {

        Instant now = Instant.now();//instant là 1 package hỗ trợ làm việc với thời gian 
        Instant validity = now.plus(this.tokenValidityInSeconds, ChronoUnit.SECONDS);
    

        // @formatter:off này là Payload
        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuedAt(now)
            .expiresAt(validity)
            .subject(authentication.getName())
            .claim(AUTHORITIES_KEY, authorities) //claim yêu cầu tham số là String, Object
            .build();

        JwsHeader jwsHeader = JwsHeader.with(JWT_ALGORITHM).build(); // header
        return this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims)).getTokenValue();//return String và đã làm theo cấu hình encode của mình cấu hình ở config/SecurityConfiguration.java
    }

các bước cơ bản: lấy được phần authentication -> tạo token (header thuật toán + authentication + SecretKey) -> ném về cho người dùng

sau đó quay lại AuthController.java chỉnh sửa ResponseEntity -> để ko gửi ra thông tin người dùng mà gửi về token cho người dùng 

Fix lỗi: khi @PostMapping("/login")
    public ResponseEntity<String> login -> trả về .body(chuỗi) mà bên phần format response RestResponse<Object> restResponse = new RestResponse<Object>(); đang yêu cầu 1 object maybe nó sẽ bị lỗi -> tạo thêm 1 ResLoginDTO.java làm Object lưu chuỗi token và chỉnh sửa lại:
	public ResponseEntity<ResLoginDTO> login -> return .body(ResLoginDTO)

cách fix cũ:
if (body instanceof String) {
            return body;
        }
-> nhưng như này khi return thì nó chỉ return về chuỗi token mà ko theo định dạng gì -> ko hợp lý 

Sau khi đã có token ở client để giải mã được token đó -> vào jwt.io paste cái token đó vào để giải mã ở đây vẫn xem được data khi mã hóa vì phần header, payload ko hề được mã hóa cái mã hóa là phần signature (đây chính là cái để pía server xác nhận 1 token là hợp lệ)

Bây h đã có token -> h mọi request gửi lên server đều pải gắn với token này và pải hợp lệ -> request mới được accept 

##XI - Bảo Vệ Endpoint (API) với JWT##
Tài liệu:
https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html#oauth2resourceserver-jwt-sansboot

để cấu hình phần JWT ko nên tự viết 1 Filter (độ an toàn ko cao) mà nên dùng cái mặc định của Spring Security cấu hình thêm pần config/SecurityCofiguration.java: .oauth2ResourceServer((oauth2) -> oauth2.jwt(Customizer.withDefaults())); khi cấu hình phần này vào http -> spring sẽ cung cấp 1 Filter BearerTokenAuthenticationFilter filter này giúp tự động tách phần token nếu gửi request đính kèm token vào pần header (nếu ko dùng Filter này -> cần pải tự viết thủ côg cách lấy token,...)


Bước 1: khai báo sử dụng JWT
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(authorize -> authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer((oauth2) -> oauth2.jwt(Customizer.withDefaults()));
	//customizer.withDefaults() như này chả có ý nghĩa gì cả chỉ có ý nghĩa về mặc ngữ páp là dùng cấu hình mặc định của function gọi nó vì nếu bấm vào function withDefaults() -> nó return về {} list rỗng :vv
    return http.build();
}

Mục đích của bước 1, là sử dụng BearerTokenAuthenticationFilter (filter sẽ tự động extract - lấy token từ header của request gửi lên server )

Sau khi khai báo như trên, nếu chạy project sẽ bị “toang”, vì khi cấu hình sử dụng JWT, ngoài cấu hình encoder (mã hóa token), chúng ta cần decoder (giải mã cái token đó ở pía backend) đọc phần log sẽ thấy nó yêu cầu 1 Bean nữa để decode required a bean of type 'org.springframework.security.oauth2.jwt.JwtDecoder' -> cần viết 1 Function hướng dẫn BearerTokenAuthenticationFilter làm sao để giải mã được token gửi lên (quy định tên thuật toán + chìa khóa) 

Bước 2: cấu hình decoder
https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/OAuth2ResourceServerConfigurer.html
 
Có 3 cách:
supply a Jwk Set Uri via OAuth2ResourceServerConfigurer.JwtConfigurer.jwkSetUri cung cấp chìa khóa đẽ có thể giải mã được (có thể cung cấp qa 1 đường link url (như 1 link lưu trữ private/public key truy cập đến link để lấy)) chứ ko làm theo cách local là khai báo biến môi trường env trong properties như chúng ta 
or
supply a JwtDecoder instance via OAuth2ResourceServerConfigurer.JwtConfigurer.decoder cung cấp 1 đối tượng

Or expose a JwtDecoder bean đây là cách ứng dụng này làm: ghi đè lại 1 cái Bean - cấu hình thông qa Bean 


//@FunctionalInterface    
@Bean
    public JwtDecoder jwtDecoder() {
        NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withSecretKey(
                getSecretKey()).macAlgorithm(SecurityUtil.JWT_ALGORITHM).build();
        return token -> {
            try {
                return jwtDecoder.decode(token);
            } catch (Exception e) {
                System.out.println(">>> JWT error: " + e.getMessage());
                throw e;
            }
        };
    }

sau khi khai báo xog Bean này mọi request gửi tới Server mà ko có gửi kèm token xác thực -> lỗi 401 unauthorized những Filter sẽ chạy trước khi vào HttpRequest cũng như là controller 

cú páp lamda được viết pần return chính là cú páp dành cho Funtionalinterface là interface chỉ chứa 1 function dùng để override lại function đó được dùng chính là cách chúng t viết ở function public JwtDecoder jwtDecoder() nếu bấm vào JwtDecoder thì đây cũng là 1 functionalInterface có đúng 1 method là decode -> khi override lại interface JwtDecoder dùng lamda -> ghi đè lại function decode và function này có tham số sẵn là token nên có thể dùng token ở pần return 
token được lấy ở Filter BearerTokenAuthenticationFilter (giải thích qá trình lấy ra token pía dưới)


Bước 3: test API: để xem việc nó tách token ntn 
Lưu ý: cần allow /login permitAll
- cần khi gửi request -> thông báo lỗi chứ ko pải chỉ hiển thị 401 ở Postman

Cần login để lấy access_token -> copy pần token 

Mỗi khi gọi API, chuyển qa tab Authorization chọn Bear token + cần truyền lên token này (sau này ở Front end sẽ tự biết làm pần này)

nếu gửi sai token -> nó sẽ set 1 header www-authenticate (theo chuẩn của Spring) để mô tả lỗi 

ngoài cái thông báo lỗi mặc định này mình sẽ làm thêm bắt Exception và gửi nó về pần body hiển thị theo format Response 

***Cách Filter BearerTokenAuthenticationFilter hoạt động (tách token + override lại decode ntn 
Ctrl + T: tìm theo Filter BearerTokenAuthenticationFilter trong này nó sẽ chạy vào Function doFilterInternal trog này nó sẽ:

- lấy ra token ở token = this.bearerTokenResolver.resolve(request); lợi khi dùng sẵn khỏi cần tự viết cách lấy token khi bấm vào resolve -> functional interface nghĩa là 1 interface chỉ có đúng 1 method -> có thể dùng cú páp lamda với kiểu này
	@FunctionalInterface
	public interface BearerTokenResolver

cú páp lamda chính là cách chúng t viết ở function public JwtDecoder jwtDecoder() nếu bấm vào JwtDecoder thì đây cũng là 1 functionalInterface có đúng 1 method là decode -> khi override lại interface JwtDecoder dùng lamda -> ghi đè lại function decode và function này có tham số sẵn là token nên có thể dùng token ở pần return token này lấy ở BearerTokenAuthenticationFilter
nhấn vào resolve(request) chỗ lấy ra token ở Filter -> Functional Interface
	@FunctionalInterface
	public interface BearerTokenResolver
có 1 function resolve bấm vào interface tìm những đứa override nó: DefaultBearerTokenResolver.class tìm đến hàm resolve nhấn tiếp vào resolveFromAuthorizationHeader(request) -> hàm resolveFromAuthorizationHeader(HttpServletRequest request) trong này nó sẽ lấy header request.getHeader(this.bearerTokenHeaderName) -> tiếp theo nó filter header 1 pattern để lấy ra token bấm vào authorizationPattern authorizationPattern.matcher(authorization) -> đây chính là pattern private static final Pattern authorizationPattern = Pattern.compile("^Bearer (?<token>[a-zA-Z0-9-._~+/]+=*)$",
			Pattern.CASE_INSENSITIVE); // bỏ đi pần "Bearer "chỉ lấy pần token pía sau 

sau khi lấy được token -> nó sẽ gửi về lại Decoder theo thuật toán + key đã được chúng ta override mà giải mã ra
	
##XII - Xử lý JWT Exception##
1.Xử lý exception

xử lý 2 ngoại lệ:
- nhập sai email, mật khẩu (lúc trước khi chưa cấu hình JWT -> chạy nó sẽ ko bắt được exception vì nó bị lỗi ở Filter chưa chạy vào controller)
    @ExceptionHandler(value = {
            UsernameNotFoundException.class,
            BadCredentialsException.class
    })
    public ResponseEntity<RestResponse<Object>> handleIdException(Exception ex)

bỏ đi pần IdInvalidException pần này sẽ làm riêng trog tham số của hàm cũng chuyển IdInvalidException thành Exception vì những lỗi khác như UsernameNotFoundException, BadCredentialsException nó sẽ ép kiểu về kiểu cha là Exception -> ko lỗi chứ nếu vẫn để nguyên IdInvalidException ép về cùng cấp maybe -> lỗi 

- sai token (Exception JWT): 
 cơ chế mặc định những cái công cụ hỗ trợ (thêm pần này trc khi cấu hình lại)
//default exception
  .exceptionHandling(
          exceptions -> exceptions
                  .authenticationEntryPoint(new BearerTokenAuthenticationEntryPoint()) //401 chưa đn
                   .accessDeniedHandler(new BearerTokenAccessDeniedHandler())) //403 yêu cầu quyền 
đây là nó sẽ set lỗi www-authentication ở header (chỉ để theo 1 chuẩn nào đó) việc cấu hình thêm 2 cái này chug quy là khi gặp exception nó sẽ xử lý lỗi theo 1 chuẩn RFC 6750 đó chứ ko có sự khác biệt rõ giữa việc thêm hay ko 
//custom
https://devlach.com/blog/java/spring-security-custom-authentication-failure

//class CustomAuthenticationEntryPoint.java (download trong source code đính kèm)

//hỗ trợ tiếng việt
 response.setContentType("application/json;charset=UTF-8");

//không làm như này nhé:
server.servlet.encoding.charset=UTF-8
server.servlet.encoding.force=true

cấu hình lại hàm này authenticationEntryPoint(cấu hình function truyền vào chỗ này BearerTokenAuthenticationEntryPoint()) là hàm ở pần cơ chế mặc định: bấm vào thì thấy nó implements 1 interface AuthenticationEntryPoint và cần override lại hàm commence() hàm này giúp can thiệp vào pần request và response để custom lại response mặc định của Spring là chỉ đưa ra lỗi ở www-authentication ở header mà ko có theo format của mìh ở body
Tạo thêm class Config: CustomAuthenticationEntryPoint
@Component // biến nó thành Bean -> tối ưu 
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final AuthenticationEntryPoint delegate = new BearerTokenAuthenticationEntryPoint();

    private final ObjectMapper mapper;//giúp chuyển data -> dạng object để gửi về dưới dạng json 

    public CustomAuthenticationEntryPoint(ObjectMapper mapper) {
        this.mapper = mapper;
    }

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        this.delegate.commence(request, response, authException);//đây là pần mặc định www-authentication ở header

        //customize
        response.setContentType("application/json;charset=UTF-8");
        RestResponse<Object> res = new RestResponse<Object>();
        res.setStatusCode(HttpStatus.UNAUTHORIZED.value());
        res.setError(authException.getCause().getMessage());
        res.setMessage("Invalided token (ko đúng định dạng, hết hạn, ...)");

        mapper.writeValue(response.getWriter(), res);//truyền lại thông tin cho client 
    }
}

hầu như là để mặc định chỉ custom sơ thêm pần dữ liệu để gửi về client 

cuối cùng là thêm pần này vào config/SecurityConfiguration.java 
	thêm .authenticationEntryPoint(null)) vào oauth2ResourceServer (vẫn giữ nguyên pần mặc định đã cấu hình trc đó: lúc này đã override lại đc 401 mặc định, 403 sẽ xử lý sau)

	null pải gáng = class đã cấu hình có 2 cách: 
		1 làm 1 Bean trong file rồi add vào như thường 
		2 cái class đó dùng @component -> khi chạy nó sẽ tạo những cái Bean như này riêng rẻ đã tích hợp sẵn thông qa Dependency Injection của Spring -> chỉ cần khai báo nó làm tham số trong hàm nhờ dùng @component -> Spring sẽ tự nhận biết đc do đang dùng class chứ ko pải tạo Bean(function) -> chỉ cần truyền tên vào 

-> đã custom được lỗi gửi ra client khi gửi sai token 
-> khi request ko gửi token chưa custom được 

cuối cùng là lưu dữ liệu vào Security Context 	

2. Lưu data vào Security Context (req.user)
nạp data vào đây để khi đăng nhập xog -> khi gửi những request khác vào controller, service cần data người dùng -> thì vào đây để lấy
//khi login luồng login tạo ra token
        Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);
        SecurityContextHolder.getContext().setAuthentication(authentication);
bây h khi set ở đây thì là thừa sau này mới dùng tới 

luồng khi gửi token lên server 
//khi decode thành công vẫn nạp thông tin vào SecurityContext (convert từ JWT -> sang data và lưu)
    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        grantedAuthoritiesConverter.setAuthorityPrefix("");
        grantedAuthoritiesConverter.setAuthoritiesClaimName(AUTHORITIES_KEY);

        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
        return jwtAuthenticationConverter;
    }
//ngoài việc nạp thông tin bth sau này khi gửi thông tin lên + quyền .... bây h chưa đụng vào phần này

##XII - Tổng kết về JWT##

1. Quá trình tạo ra/mã hóa Token (encode)

- Khi nào tạo ra token: người dùng login thành công, server cần trả ra token gửi cho client.
- Tất cả các request sau này gửi lên server truy cập API, client cần truyền lên token này để định danh (xác thực)

Quá trình encode gồm các bước:
	JWT = header.payload.signature
	Phần header bao gồm thông tin về thuật toán mã hóa => khai báo thuật toán
	Phần payload là data truyền theo token (được dùng để định danh người dùng)
	Phần signature là chữ ký, được tạo ra bằng cách : JWK (key) + thuật toán +  ký vào (header + payload) 

=> với Java Spring, cần cấu hình  JwtEncoder(tạo encoder trong này cần key và thuật toán), khai báo Key + thuật toán (thông qa function getSecretKey() lấy key và thuật toán thông qa biến môi trường)
   @Bean
    public JwtEncoder jwtEncoder() { return new NimbusJwtEncoder(new ImmutableSecret<>(getSecretKey())); } việc return như này là 1 cách code tắt bấm vào NimbusJwtEncoder -> thì hàm tạo của nó JWKSource<SecurityContext> cần truyền vào JWKSource còn mình truyền vào ImmutableSecret (ImmutableSecret kế thừa lại ImmutableJWKSet mà ImmutableJWKSet kế thừa JWKSource) -> quan hệ kế thừa 

//todo: giải thích code

2. Quá trình giải mã Token (decode)

- Client muốn truy cập & sử dụng API, cần truyền lên Token (đã có từ bước login) tại header của Request, thông thường là dạng Bearer you-token-here
Bước 1: client gửi kèm JWT token ở header request
Bước 2: Tại phía Server của Spring (sau khi đã cấu hình oauth2-resource-server), sẽ kích hoạt filter BearerTokenAuthenticationFilter

- Filter này sẽ “tự động tách” Bear Token (bạn không cần phải làm thủ công, thư viện đã làm sẵn rồi)

Token sẽ được xử lý tiếp, thông qua:
JwtDecoder : giải mã token (check tính hợp lệ của token)
Check như thế nào :  
JWT = header.payload.signature

Decoder sẽ tách header, payload, đồng thời lấy Key + thuật toán để băm ngược ra signature

Nếu 2 signature là trùng nhau => token hợp lệ. 

Quá trình này tương tự việc so sánh mật khẩu khi login (băm mật khẩu thành hash để so sánh với database, nếu trùng nhau, tức là nhập đúng thông tin)


JwtAuthenticationConverter  : convert data chứa trong token, lưu  vào Spring Security Context 

Fix: khi gửi request đến server nhưng ko gửi lên token -> chưa custom response đó được 
	comment cấu hình mặc định này lại: 
	// .exceptionHandling(
                //         exceptions -> exceptions
                //                 .authenticationEntryPoint(customAuthenticationEntryPoint) // 401 chưa đn
                //                 .accessDeniedHandler(new BearerTokenAccessDeniedHandler())) // 403 yêu cầu quyền
	Lỗi là vì ở class CustomAuthenticationEntryPoint.java cần sửa lại trong function commence()
String errorMessage = Optional.ofNullable(authException.getCause()).map(Throwable::getMessage)
                .orElse(authException.getMessage()); để kiểm tra nếu ko gửi lên token authException.getCause() = null -> lỗi câu lệnh này check nếu nó null thì trả ra authException.getMessage() ko thì tra ra authException.getCause().getMessage()


====Chapter 8: Phân tích dự án thực hành====

Phân tích và thiết kế dự án thực hành của khóa học

##I - 60. Giới thiệu dự án thực hành## 

1.Về dự án thực hành

Ý tưởng dự án, tham khảo nhanh tại đây

Đề tài : website việc làm (ý tưởng itviec.com)

Các đối tượng tham gia:
	Users (có phân quyền chi tiết): HR, Admin, normal user
	Permission/Role
	Company (công ty đăng tin tuyển dụng)
	Job/Resume
	Subscriber (đăng ký nhận tin tuyển dụng qua email)

##II - Setup dự án thực hành Frontend##

1. Cài đặt Node.js
Nodejs là môi trường chạy code javascript, tương tự JDK để chạy code Java

Version node.js mình sử dụng là 16.20.0:
https://nodejs.org/download/release/v16.20.0/

Cài chính xác version để hạn chế tối đa lỗi có thể xảy ra. (nvm)

Kiểm tra đã cài đặt thành công với câu lệnh: node -v

2. Cài đặt dự án Frontend

Bước 1: download dự án Frontend https://drive.google.com/file/d/1FuUnBoDYMjwSMpZWeXE7mry6rXwJY5rw/view
(đã ứng với branch cors)

Bước 2: cài đặt các thư viện cần thiết với câu lệnh
npm i

Bước 3: update file .env.development  và .env.production 
//update url backend

Bước 4: chạy dự án
//chạy tại dev
//chạy tại production

##III - CORS##

1. Minh họa lỗi
Mở source code frontend
	Bước 1: cài đặt thư viện cần thiết npm i
	Bước 2: chạy dự án ở chế độ dev
	//lưu ý: backend chạy tại localhost:8080

	npm run dev

Chờ 1 xíu để browser lưu cache, truy cập: http://localhost:3000/

F12, check tab network
(failed)net::ERR_CONNECTION_REFUSED => chưa chạy backend

chạy Backend lên sẽ ko còn thấy lỗi (failed)net::ERR_CONNECTION_REFUSED mà thấy lỗi CORS Nếu không thấy lỗi CORS error cũng chẳng sao (máy này ko thấy và hiện lỗi 401)

2. CORS là gì 
https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
Cross-Origin Resource Sharing (CORS) là câu chuyện Server cho phép tên miền nào có quyền load tài nguyên của nó lỗi này CHỈ xảy ra khi dùng trình duyệt Browser

đây là 1 cơ chế định nghĩa pần Header: ở tab network-fetch/XHR (nơi chỉ xét những lời gọi API) bấm vào localhost-header trong này có 1 trường trong Header là Referrer Policy cái này sẽ quy định mỗi một lần gọi API từ Frontend -> mặc định chỉ được pép dùg 1 tên miền nếu khác -> sẽ bị lỗi CORS

Server: localhost:8080
Client: localhost:3000 => khác nhau ở port nên bị chặn CORS

Như khóa Spring MVC, dùng SSR, cả server và client đều là localhost:8080 nên không bị



Tại sao lại cần CORS ?
Tất cả lý do cơ chế cookies của browser. Cookies lưu thông tin người dùng (dùng định danh người dùng, tương tự session_id)

Với code frontend, nếu gọi API từ client tới server, browser sẽ tự động đính kèm cookies ứng với server đấy.

Thử tưởng tượng case sau:

Bạn dùng browser, bạn sử dụng facebook.com
=> browser sẽ lưu cookies của bạn ứng với server facebook.com 
(mục đích mỗi lần bạn refresher, hoặc vài tuần sau bạn quay lại facebook mà không cần đăng nhập/định danh bạn là ai)

Bạn chat với 1 người lạ trên facebook, gửi cho bạn 1 đường link hot-girl.xyz
Bạn nhấn vào link, và truy cập hot-girl.xyz

Nếu không có cơ chế CORS, và trang web hot-girl.xyz là do hacker dựng lên, nó sẽ code như sau:
Từ hot-girl.xyz gọi API của facebook.com, ví dụ: facebook.com/getPhoneNumber
=> lấy thông tin số điện thoại sau lưng bạn :v 

API trên sẽ gọi được (mà không cần đăng nhập vào facebook), vì mặc định, browser sẽ gửi kèm cookies của facebook.com (khi bạn gọi tới server đấy)

=> để tránh tình trạng trên, mặc định, các browser hiện đại sẽ có cơ chế CORS (default).

Có nghĩa là, dùng browser, không thể từ hot-girl.xyz gọi tới facebook.com (vì khác tên miền)
Tương tự với case của chúng ta: từ localhost:3000 không thể gọi tới localhost:8000

##IV - Cách fix CORS##
Cơ chế CORS sinh ra để giúp lướt web an toàn hơn, và cung cấp thêm sức mạnh cho server, khi có thể quyết định “tên miền nào” có thể truy cập nguồn tài nguyên của nó

=> muốn fix CORS, nên fix ở Server (cách thực tế sử dụng)

Mô hình áp dụng: client - server thông qua Restful API, đang bị CORS, có các cách fix sau:

Cách hiệu quả nhất (được dùng trong khóa học), là cấu hình CORS tại backend, như vậy frontend chỉ dùng và không cần phải sửa đổi gì

Tuy nhiên, khi đi làm trong thực tế, nếu server (API) không do bạn viết, hoặc đối tác cung cấp không thể sửa đổi thì làm thế nào ?

Cách 1: disabled security của browser 
https://stackoverflow.com/questions/3102819/disable-same-origin-policy-in-chrome
=> không khuyến khích dùng cách này

Cách 2: không sử dụng browser trực tiếp, mà dùng server - server 
(khuyến khích dùng cách này, vì control 100%)

CORS chỉ xảy ra giữa browser và server. Còn server gọi server sẽ không có CORS

Nếu client => gọi Server A bị CORS (server này bạn ko kiểm soát), thì:

Client => gọi Server B (server này bạn kiểm soát, sẽ setup CORS) => gọi Server A

Cách 3: dùng proxy cho code frontend (again, bạn cần tìm hiểu công cụ sử dụng có dùng proxy hay không)

Client => gọi proxy => gọi server A (thứ bạn không kiểm soát). Như vậy, nó sẽ gần giống như cách 2 ở trên. proxy khi gọi API đến Server -> sẽ giúp dấu đi URL đến Backend mà dùng URL đã được cấu hình 
Bạn nào dùng nginx (reverse proxy sẽ hiểu :v )

##V -  Spring và CORS##
Tài liệu:
https://docs.spring.io/spring-security/reference/servlet/integrations/cors.html

***muốn fix nhanh cho từng API dùng Annotation: @CrossOrigin

Phạm vi cấu hình CORS: local hoặc global
https://docs.spring.io/spring-framework/reference/web/webmvc-cors.html#mvc-cors-intro

Tham khảo Jhipster:
	Cấu hình env
	Cấu hình filter

1.Cấu hình CORS
Mặc định, spring security hỗ trợ sẵn org.springframework.web.filter.CorsFilter đây là 1 Filter có sẵn mặc định của Spring Security để cấu Hình pần CORS 

-> cấu hình lại nó 

khai báo nó ra pần HttpRequest
	                .cors(Customizer.withDefaults()) // đây là cỉ khai báo gọi nó ra và dùng cấu hình mặc định 


Tạo bean: khi tạo Bean như này: @Bean + @Configuration -> Spring sẽ tự ghi đè cấu hình mặc định của org.springframework.web.filter.CorsFilter 

@Configuration
public class CorsConfig {

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
configuration.setAllowedOrigins(Arrays.asList("http://example.com"));         configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS")); // Allowed methods
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type", "Accept"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
 // How long the response from a pre-flight request can be cached by clients

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration); // Apply this configuration to all paths
        return source;
    }
}


====Chapter 9: Modules Company====

##I - Model Company## 

1. Tạo model Company
companies			
	id		long	
	name		String	
	description	String	 => Text
	address		String	
	logo		String	
	createdAt	Date	
	updatedAt	Date	
	createdBy	String	
	updatedBy	String	

@Column(columnDefinition = "MEDIUMTEXT")
private String description;
https://stackoverflow.com/a/13932834


https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html
 private Instant createdAt;

đối với 4 trường thông tin: createdAt, updatedAt, createdBy, updatedBy -> sẽ ko gán giá trị ở controller mà viết trực tiếp trong model dùng Hook (life circle của hibernate) lấy thông tin từ Spring security ra để cập nhật 

Sử dụng lombok (dùng thư viện này để nó cung cấp 1 số annotation cho các model -> giúp tự động generate setter/getter/....)
https://projectlombok.org/#
https://projectlombok.org/setup/gradle

-> cài đặt thông qa sử dụng plugins (sử dụng thư viện mã nguồn mở) nếu cài thông thường trong gradle -> cần cài khá nhiều dependencies
-> thêm đoạn này vào plugins trong gradle id("io.freefair.lombok") version "8.6" khi cài đặt plugin này -> nó sẽ kéo lombok về và nó tự cấu hình (lombok) cho dự án 
plugins {
  id("io.freefair.lombok") version "8.6" 
}

sau đó dùng các Annotation @Setter, @Getter cho model -> import từ lombok ko nên dùng cho toString hay hàm tạo (@Data) 

//format date global tải https://drive.google.com/file/d/1tAvG9r5RglSrO-jDITZC6CKJmy3ENBfR/view cấu hình định dạng date 

American vs. European Date Formats:
American (MM/dd/yyyy): 12/31/2023 (December 31, 2023)
European (dd/MM/yyyy): 31/12/2023 (31 December 2023)

24-Hour Clock (HH:mm:ss): "23:45:00" (11:45 PM)
12-Hour Clock (hh:mm:ss a): "11:45:00 PM"

ISO 8601 Standard:
Date and Time Combined (yyyy-MM-dd'T'HH:mm:ss'Z'): "2023-12-31T15:45:30Z"

UTC Offset: "2023-12-31T10:15:30+01:00" (Time in UTC+1 zone)
Named Time Zones: "2023-12-31T09:15:30 Europe/Paris"


##II - Before Save Entity với JPA (Part 1)##

Tài liệu: https://stackoverflow.com/questions/45064420/business-logic-before-to-save-an-entity-in-spring-jpa
https://docs.jboss.org/hibernate/orm/6.5/userguide/html_single/Hibernate_User_Guide.html#events-jpa-callbacks
https://www.baeldung.com/jpa-entity-lifecycle-events
https://www.timestamp-converter.com/

Làm 2 việc: update thông tin của company trước khi lưu vào database ở model chứ ko làm ở (Controller hay Service) 

1 - Thêm thông tin người tạo + thời gian tạo
- dùng Entity Listeners and callback methods đây là của thư viện Hibernate ko pải của JPA 
- Về thư viện: thì trong các dependencies như data-jpa hay validation nó đã cài sẵn một vài thư viện của Hibernate đủ dùng cho pần này -> ko cần cài thêm gì 
- Có 2 cách: 
	Khai báo 1 Listeners cho 1 class @EntityListeners(class=Audit.class) ~ AOP mọi hành động đều pái ghi lại lịch sử (input đầu vào, output đầu ra, ...) 
	Callback function(dùng cái này): dùng các Annotation này cho các function tương ứng 
		@PrePersist: trước khi lưu vào database
		@PreRemove: --- xóa
		@PreUpdate: --- cập nhật
		@PostPersist: sau khi lưu vào database
		@PostRemove: --- xóa
		@PostUpdate: --- cập nhật 
		@PostLoad: sau khi load data 	
	Lưu ý khi dùng callback function:
		kiểu trả về pải là void
		ko có tham số truyền vào


    @PrePersist
    public void beforeSave() {
        this.createdBy = "Thanh Trong";
        this.createdAt = Instant.now();
    }

thời gian ở đây lưu thêm chuẩn ISO: giờ đag hiển thị lỗi vì đây mặc định + múi giờ 0 nhưng ở VN thì pải + múi g 7

##III - Before Save Entity với JPA (Part 2)##
1. Format timezone
https://www.digitalocean.com/community/tutorials/java-8-date-localdate-localdatetime-instant
https://stackoverflow.com/questions/71854271/java-instant-datetime-how-to-get-the-datetime-with-timezone-offset-only-without

đối với instant -> ko cấu hình được pần time zone (tức là mặc định nó dùng time zone ~ GTM+0 -> nếu ko ép kiểu khác sẽ ko +7 lên được ví dụ convert sang ZonedDateTime để chuyển đổi kiểu dữ liệu lưu vào database)

nhưng ở đây sẽ ko làm vậy mà vẫn dùng instant vì instant sẽ lấy chính xác h tại máy tính (server) đag đứng -> nếu bây h cấu hình GTM+7 nếu qa địa điểm khác cần cấu hình lại -> giải páp vẫn lưu GTM+0 ở database và dùng 1 Annotation để format nó thành GTM+7 ở backend sau khi lấy nó ra khỏi database và trc khi truyền nó ra view 

Annotation @JsonFormat(pattern = "", timezone = "") cái này được import từ thư viện Jackson -> dùng thư viện này thường sẽ xử lý trả về cho frontend 

ở đây là Format ở Backend -> trả về cho Frontend thực tế ta có thể Format tại Frontend

2. Spring Security Context
//tham khảo https://drive.google.com/file/d/1Yy0wMPtMTmyfBmX5ylH6HK9ipW2Vd5Pp/view

lấy thông tin người tạo company (người dùng hiện tại) để gán vào createdBy trước khi lưu xún database qa dữ liệu đã lưu vào SecurityContext thông qa SecurityContextHolder 

ở AuthController.java khi đăng nhập thành công t lưu thông tin authentication vào:         SecurityContextHolder.getContext().setAuthentication(authentication); -> ta sẽ lấy người ra từ đây -> getAuthentication()

copy các function trong link trên: trong code thì lấy email qa function getCurrentUserLogin() trong này nó gọi đến function extractPrincipal(Authentication authentication) trong này nó sẽ kiểm tra và thấy thông tin từ authentication và kiểu của authentication.getPrincipal() là instance của Jwt sau đó nó gán jwt = authentication.getPrincipal() -> lấy ra tên email thông qa jwt.getSubject(): rõ hơn về qá trình lấy email này
	hàm getSubject() này là của class JwtClaimAccessor 
	default String getSubject() {
		return this.getClaimAsString(JwtClaimNames.SUB);
	}
thông qa getClaim và JwtClaimNames.SUB trong jwt có pần claim là 1 kiểu collection chứa từng cặp key,value SUB là key của pần email 
có 1 cái key là Nguyen Van Thanh Trong được set ở config/SecurityConfiuration.java ngay chỗ convert từ Jwt -> authentication để lưu vào SecurityContext grantedAuthoritiesConverter.setAuthoritiesClaimName("Nguyen Van Thanh Trong"); ngày pần claimName || trong pần function CreateToken mình có lưu email của người dùng đăng nhập thành công trong subject .subject(authentication.getName()) -> sẽ lấy email qa subject chứ ko thông qa claim -> sau này sẽ sửa đổi thông tin trong claim này để truyền cho Frontend 

có 1 số cú páp code mới: if (authentication.getPrincipal() instanceof UserDetails springSecurityUser) câu trong if này kiểm tra authentication.getPrincipal() có pải kiểu UserDetails nếu pải thì gán nó vào biến springSecurityUser 

##IV - Query với Pagination##

Vấn đề : Lấy danh sách công ty
GET http://localhost:8080/companies

Cần truyền lên JWT ở header, và không truyền data ở body
=> Nếu data nhiều, thời gian fetch sẽ lâu, và người dùng cũng không xem hết data 
=> không hiệu quả
Ví dụ: https://shopee.vn/Th%E1%BB%9Di-Trang-Nam-cat.11035567

1.Cách xử lý phân trang

Về nguyên tắc: sử dụng offset và limit của SQL 
https://www.sqltutorial.org/sql-limit/

=> frontend sẽ truyền lên page và limit => backend sẽ tự tính offset

Với Repository:
JpaRepository kế thừa PagingAndSortingRepository
Page<T> findAll(Pageable pageable);

=> cần truyền lên đối tượng Pageable là sẽ được phân trang

2. Cách thực hiện

Bước 1: Frontend truyền lên 2 tham số: 
current //page hiện tại
pageSize //số lượng bản ghi muốn lấy

@RequestParam("current") Optional<String> currentOptional,
@RequestParam("pageSize") Optional<String> pageSizeOptional


Bước 2: Tạo đối tượng Pageable

//page tính từ 0
Pageable pageable = PageRequest.of(page - 1, limit); //PageRequest qan hệ cháu với Pageable 

//truyền sang repository => done
Page<Company> findAll(Pageable pageable); -> chuyển về dạng list dùng .getContent() cái này là của Slice và Page kế thừa lại của Slive

Bước 3: format output
//cần tạo DTO để return data cho client

Output:
return {
      meta: { 
        current: page, //trang hiện tại
        pageSize: limit, //số lượng bản ghi đã lấy
        pages: totalPages,  //tổng số trang với điều kiện query
        total: totalItems // tổng số phần tử (số bản ghi)
      },
      result: array-data //kết quả query
    }
cách ở trên đã làm ở Spring MVC
 // test Pageable
    @GetMapping("/companies")
    public ResponseEntity<ResultPaginationDTO> getCompanies(@RequestParam("current") Optional<String> currentOptional,
            @RequestParam("pageSize") Optional<String> pageSizeOptional) {
        String currentPage = currentOptional.isPresent() ? currentOptional.get() : "";
        String pageSize = pageSizeOptional.isPresent() ? pageSizeOptional.get() : "";
        Pageable pageable = PageRequest.of(Integer.parseInt(currentPage) - 1,
                Integer.parseInt(pageSize),
                Sort.unsorted());// trừ 1 vì PageNumber của hàm of này sẽ tính từ 0
        return ResponseEntity.ok(this.companyService.fetchCompanies(pageable));
    }


Ngoài những cách ở trên pageable Spring cũng hỗ trợ sẵn cho chúng ta nhưng pải theo cú páp của nó trên url: pải có params page=...&size=...&sort=tên thuộc tính mún sort,desc||asc (nếu ko thì mặc định nó sẽ là unsort) -> controller chỉ cần khai báo tham số là Pageable -> thì Spring sẽ tự ép kiểu 2 params đó về thành Pageable luôn ko cần pải tự set

nhưng khi dùng cái của Spring có 1 cái tồn động là trang nó tính từ trang thứ 0 -> mà frontend gửi lên từ 1 -> lỗi -> pải cấu hình lại cho nó bắt đầu từ 1 ngoài ra có thể cấu hình max số lượng sản pẩm trog 1 trang khi hiển thị để tránh người dùng gửi lên qá lớn ... thông qa những link dưới cấu hình trog file properties 
spring.data.web.pageable.one-indexed-parameters=true //bắt đầu từ 1 ở đây là nó sẽ xử lý khi nhận từ Frontend truyền vào Pageable tự động -1 cho chúg ta ở duy nhất controller pía sau nó vẫn bắt đầu từ 0 nên trong service vẫn pải set meta.setPage(pageable.getPageNumber() + 1) + 1 cho nó hiển thị ra Frontend đúng

//cấu hình pagination:
https://stackoverflow.com/questions/39884860/how-to-configure-spring-boot-pagination-starting-from-page-1-not-0

https://docs.spring.io/spring-boot/appendix/application-properties/index.html#application-properties.data.spring.data.web.pageable.default-page-size

##V - Giới thiệu về Specification##

//review phần filter của company và fix bug pageNumber + 1

1. Giới thiệu về Specification
https://docs.spring.io/spring-data/jpa/reference/jpa/specifications.html

Bước 1: repository kế thừa JpaSpecificationExecutor<T>

Nhờ việc kế thừa này, chúng ta có method findAll (truyền thêm Specification)
List<T> findAll(Specification<T> spec);

Page<T> findAll(Specification<T> spec, Pageable pageable); -> cần truyền vào Specification

Specification là 1 interface trong này chỉ có duy nhất 1 function -> cần override lại là Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder criteriaBuilder) -> cần return về 1 Predicate đối tượng này thực tế chỉ trả ra True/False 
Predicate được kế thừa bởi CriteriaBuilder -> dùng class này có 1 số function trả về kiểu Predicate

trong hàm này qan trọng nhất là tạo ra Builder -> để xác định điều kiện query

Bước 2: build specification (cú pháp của predicate và CriteriaBuilder)

https://docs.oracle.com/javaee/7/api/javax/persistence/criteria/CriteriaBuilder.html

public class CustomerSpecs {

  public static Specification<Customer> isLongTermCustomer() {
    return (root, query, builder) -> { //đây là lamda, ghi đề hàm toPredicate
      LocalDate date = LocalDate.now().minusYears(2);
      return builder.lessThan(root.get(Customer_.createdAt), date);
    };
  }

}

Bước 3: Áp dụng tại service/controller, ví dụ:

List<Customer> customers = customerRepository.findAll(isLongTermCustomer());

2. Vấn đề tồn đọng

Cần viết thủ công từng predicate (Specification) ứng với từng tiêu chí filter
Ví dụ: filter theo name, address, price …

Không tái sử dụng được logic giữa các Entity có điểm tương đồng, ví dụ entity User và Employee đều có chung thuộc tính name => vẫn viết 2 specification || đây là cách sử dụng ở Spring MVC 

Giải pháp 1: sử dụng generic để tái sử dụng
https://stackoverflow.com/questions/71904939/jpa-specification-generic-type-class
https://stackoverflow.com/questions/61241257/how-to-use-single-jpa-specification-class-and-methods-for-multiple-entities

Ưu điểm: có thể tái sử dụng code, và bạn control 100% (từ a tới z)
Nhược điểm: viết = cơm (có nghĩa là bạn tự code)

Giải pháp 2: sử dụng thư viện
Ví dụ:
https://github.com/querydsl/querydsl
https://docs.spring.io/spring-data/jpa/reference/repositories/core-extensions.html

Ưu điểm: có thể tối ưu hóa query cho bạn (out-of-the-box)
Nhược điểm: bạn cần tốn thời gian để học cú pháp của thư viện đấy

Giải pháp đề ra: sử dụng “code thuần” hay thư viện không quan trọng
Điều quan trọng nhất là luyện khả năng tư duy logic

-> cả 2 loại này đều ko dùng cho dự án này - dự án này sẽ dùng thư viện nhưng ko dùng thư viện ở Giải páp 2

##VI - Query với Filter (Part 1)##
//source code video này sẽ được gộp vào part 2

1.Cài đặt thư viện
dùng 1 thư viện mã nguồn mở SpringFilter https://github.com/turkraft/springfilter là thư viện do cộng đồng community, các lập trình viên làm chứ ko pải của Spring là thư viện đang được bảo trì maintain 

https://mvnrepository.com/artifact/com.turkraft.springfilter/jpa/3.1.7
https://github.com/turkraft/springfilter
// https://mvnrepository.com/artifact/com.turkraft.springfilter/jpa

implementation("com.turkraft.springfilter:jpa:3.1.7") // cần cài thêm version ở cuối vì cái này ko dùng kế thừa theo Spring -> ko ăn theo pần Spring boot cấu hình ở plugin mà của community 

2. Sử dụng thư viện (lưu ý: chưa làm pagination và sorting)
https://github.com/turkraft/springfilter?tab=readme-ov-file#jpa-integration

Bước 1: cập nhật repository để có thể sử dụng Specification
@Repository
public interface UserRepository extends 
        JpaRepository<User, Long>,
        JpaSpecificationExecutor<User>
{
   
}

Bước 2: update controller
sau khi cài thư viện sẽ cho dùng annotation @Filter về cú páp thì ko có trang nào ghi gõ -> chỉ có link github hướng dẫn cấu trúc || cách code 

khi dùng @Filter Specification (Annotation này sẽ giúp các params sau ?filter=... truyền trên url ở Frontend sẽ được ép kiểu về Specification về cho biến sở hữu annotation này) ở pần tham số của controller thì pần params ở Frontend pải theo format ví dụ trên github bắt buộc pải có ?filter="các điều kiện": ?filter= average(ratings) > 4.5 and brand.name in ['audi', 'land rover'] and (year > 2018 or km < 50000) and color : 'white' and accidents is empty....

các Repository muốn dùng pải kế thừa JpaSpecificationExecutor<T> (interface này cũng giúp cung cấp vài function filter theo Specification)

đây là cách làm đơn giản chỉ mới làm với Specification và chưa kết hợp pân trang controller chỉ cần dùng annotation Filter và truyền ở pần params theo format: ?filter=username:'user@gmail.com' and name~'IT',... -> Annotation này giúp ép kiểu các params sau filter thành specification -> rồi chuyển qa service làm 
@GetMapping("/companies")
    public ResponseEntity<ResultPaginationDTO> getCompanies(@Filter Specification<Company> spec) {
        return ResponseEntity.ok(this.companyService.fetchCompanies(spec));
    }

Bước 3: test với frontend
//todo

##VII - Query với Filter (Part 2)##

//sử dụng pagination và sorting
https://www.baeldung.com/spring-data-sorting

Tương tự Spring REST project:
https://docs.spring.io/spring-data/rest/reference/paging-and-sorting.html

đối với Spring, hỗ trợ out-of-the-box đối tượng Pageable, nếu truyền lên url:
page
size
sort 	

Ví dụ: page=2&size=2&sort=price,asc

##VIII -  Customize Message với Annotation (Extra)##
Tham khảo:
https://stackoverflow.com/questions/12260037/how-to-create-custom-annotation-in-java
https://www.digitalocean.com/community/tutorials/java-annotations
//java reflection: https://www.oracle.com/technical-resources/articles/java/javareflection.html

về Annotation bản chất là của Java và JavaSpring chỉ kế thừa lại 
dự án này sẽ viết 1 annotation sau đó dùng nó ở ControllerAdvice tức là trước khi truyền dữ liệu về cho frontend sẽ custom sơ thêm nữa -> gửi về có ý nghĩa hơn

1 Annotation sẽ có 3 pạm vi hoạt động:
	cho class
	cho mehthod
	cho trường thông tin

mô hình: 
client gửi req -> server (server pải xử lý và gửi về pản hồi) cần pải qa: controller, service, ... nhiều tầng khác và annotation ở đây sẽ là các meta data (thông tin pụ) được đính kèm vào sau khi qa các tầng và qá trìh đính kèm này xảy ra khi đag chạy code chứ ko pải lúc dịch code (đây là qá trình RUNTIME đag chạy) (ngoài ra có thêm qá trìh nữa là compile time là lúc dịch code chưa chạy dự án)

để can thiệp vào qá trìh chạy dự án (RUN TIME) có 1 API là Java Reflection(tự tìm hiểu thêm)

sau khi tạo annotation để sử dụng thì cần thông qa các API của Java nó cho pép sử dụng: annotation trag trí cho class, method, element -> phụ thuộc vào nơi lấy annotation (annotation giúp can thiệp trog qá trình chạy) -> nơi đag chạy khác nhau sẽ có cách lấy annotation khác nhau
	Muốn lấy ra bên trong class -> có thể dựa vào chính class đó lun và class đó pải được trang trí bởi annotation đó 
	hay bây h mún lấy nó từ Exception bên trong controllerAdvice:  bây h sẽ viết annotation bên trong 1 url/api trong cotroller -> muốn lấy annotation trang trí cho url/api đó nhưng lấy ở controllerAdvice -> 2 nơi khác nhau -> thì pải tìm côg cụ hỗ trợ tùy thuộc vào trường hợp/nơi đang đứng

Bước 1: tạo ra annotation
https://www.geeksforgeeks.org/java-retention-annotations/

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ApiMessage {
    String value();
}

Bước 2: sử dụng annotation
@GetMapping("/users")
@ApiMessage("fetch all users")
public ResponseEntity<ResultPaginationDTO> getAllUser()

Bước 3: Lấy giá trị của annotation
//phụ thuộc vào nơi bạn lấy giá trị của annotation, sẽ có các cách lấy giá trị khác nhau
https://stackoverflow.com/a/47922587

đối với dự án này sẽ lấy ở trong FormatRestResponse thông qa tham số đầu vào MethodParameter returnType và lấy thông qa ApiMessage message = returnType.getMethodAnnotation(ApiMessage.class);  cần truyền vào class muốn lấy anntation nào thì truyền vào class viết annotation đó (nó pải chạy qa controller -> FormatRestResponse -> sau đó mới lấy giá trị của Annotation và chỉ lấy khi nó có giá trị vì nếu t chạy luồng khác (cụ thể là qa API/url khác -> ko qa method trog controller được trang trí nó) -> ko có giá trị)

//MethodParameter returnType
ApiMessage message = returnType.getMethodAnnotation(ApiMessage.class);


##IX - Versioning  API##
Yêu cầu:
Update api, bắt đầu với tiền tố: /api/v1/
Ví dụ: https://developers.facebook.com/tools/explorer/

version sẽ đáh giá qá trìh pát triển pần mềm -> mỗi version có thể có những thay đổi nhất định để đánh dấu version có khác nhiều cách 1 trog số đó là đánh dấu trực tiếp vào url kèm theo api đối với version đó 
	ghi trực tiếp vào url (cách phổ biến nhất)
	can thiệp và header pần content-type thay version vào đây
	tự tạo header -> ném ra



Tham khảo:
- Cách làm thủ công (đánh version): https://stackoverflow.com/a/39066141
làm thủ công -> tạo 1 annotation ApiVersion trang trí vào class/method/element cần customize lại qá trìh xử lý @RequestMapping can thiệp vào spring = cách kế thừa lại RequestMappingHandlerMapping sau đó sau khi annotation chạy -> cần quét qa annotation đó -> để nói cho spring biết nên chạy controller/method nào để pù hợp với version đó -> khá pức tạp

việc tổ chức api này sẽ có 2 cách:
	code tất cả version bên trong 1 source code (dùng cho dự án nhỏ ít thay đổi -> nếu thay đổi thì có thể ảh hưởng đến các phần còn lại) như kiểu stateful
	code chia ra mỗi version mỗi source code (làm nhiều hơn nhưng rất linh động thay đổi || điều chỉnh cho từng version thoải mái) như kiểu stateless

đối với dự án này sẽ làm đơn giản: thay vì việc tạo thêm 1 annotation -> chỉ cho dự án có 1 version -> sử dụng annotation có sẽ là RequetsMapping (khai báo với pạm vi là class và tất cả method bên trong class sẽ kế thừa lại)
-> bây h muốn all api trong class UserController pải bắt đầu = /api/v1 -> bên trên class UserController thêm annotation @RequestMapping("/api/v1")

nếu muốn khai báo động đối với version thì có thể khai báo vào .properties 

- Thư viện: https://github.com/lkqm/spring-api-versioning


====Chapter 10: Modules User====
Thực hiện CRUD với model User

##I - Update User Model##

//cập nhật các thông tin sau
id		long
name		String
email		String
password	String
age		int
gender		Enum // MALE/FEMALE
address		String
refreshToken	String
createdAt	Date
updatedAt	Date
createdBy	String
updatedBy	String

đối với giới tính -> ko hashcode dữ liệu mà dùng enum 

1. Giới thiệu về Enum
https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html

dùng enum -> có thể thay đổi dữ liệu cho những trường sử dụng nó sau này nếu cần thay đổi 1 cách linh hoạt 
cấu hình khi tương tác ở controller thì dùng enum -> database thì lưu dưới dạng String vì trog code model thì trường thông tin Gender có kiểu enum nhưng database thì ko có kiểu dữ liệu này -> sẽ ko hoạt động -> dùng Annotation @Enumerated(EnumType.ORDINAL/STRING) với ordinal thì nó sẽ lưu dạng 0,1,2... 

//sử dụng enum với Entity
https://stackoverflow.com/questions/67825729/using-enums-in-a-spring-entity

https://dev.to/noelopez/spring-rest-working-with-enums-ma

//enum so với constant
Việc sử dụng enum sẽ ép kiểu dữ liệu chặt hơn so với constant => an toàn hơn cho dự án của bạn
https://stackoverflow.com/questions/11575376/why-use-enums-instead-of-constants-which-is-better-in-terms-of-software-design


##II - CRUD User##
1 - Create user
	kiểm tra email đã tồn tại hay chưa (throw exception)
	dùng DTO để chỉ trả về thông tin user ko có password + chỉ hiển thị createdAt (dùng cách này kiểm soát all)
	hoặc dùng @JsonIgnore(trong model) để bỏ qa những trường ko muốn đưa lên view 
2 - Read User
	bỏ password

3 - Update user
	tương tự như trên 

4 - Delete user

##III - API Login##

1. Trả về phản hồi cho api, bao gồm access_token và thông tin của user, theo format sau:
{
    accessToken: "JSON WEB TOKEN",
    user:  {
        email: "hoidanit@gmail.com",
        name: "Hỏi Dân IT",
        id: "25"
       }
}

quá trình đăng nhập ở AuthController.java thì chúng ta chỉ lấy được email + password gửi lên từ pía frontend
quá trình đăng nhập và xử lý thông tin sẽ xảy ra ở đây Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken); -> nó sẽ chạy vào UserDetailsCustom.java -> loadUserByUserName() trong này có set 1 số thông tin của người dùng trả về kiểu User của hệ thôngsau đó return về chỗ Authentication -> nếu muốn lấy thông tin từ đây trong này có principal lưu 1 số thông tin mặc định mà hệ thống quy định -> một số thông tin cần thiết muốn lấy thêm sẽ ko được lưu vào đây -> cần cấu hình lại mà all thông tin của người dùng đều lưu trong princical mà kiểu dữ liệu của biến này là User(của hệ thống) -> cần override lại User này dùng User của mình (kế thừa lại UserDetails (đây là cách khá pức tạp)

cách làm đơn giản hơn là sau câu lệnh xác thực -> đã đăng nhập thành công sẽ query trực tiếp user đó xún database = email -> nạp thông tin cần thiết vào DTO rồi gửi ra view 


2. refresh_token sẽ lưu vào cookies

##IV - Set Cookies (Part 1)##
//source code video này được gộp vào #84

1.Giới thiệu về cookies
https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies

Với browser, để lưu trữ data của user, có 3 cách hay dùng nhất: 
Local Storage : thông tin được lưu trữ mãi mãi, không bao giờ mất
Session Storage: bạn đóng browser là thông tin lưu trữ sẽ clear

Cookies: chỉ mất khi và chỉ khi “bị hết hạn” (không liên quan gì tới việc đóng browser)

// các thuộc tính thường dùng
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie
Expires : thời gian hết hạn, định dạng Date
Max-Age: thời gian hết hạn, định dạng number (seconds) (độ ưu tiên cao hơn Expires)
HttpOnly : boolean (thường set = true để không cho client JS truy cập/sử dụng cookie mà chỉ có server mới lấy được cookies)

//cơ chế thường dùng trong mô hình stateless (liên quan tới cookies)
Người dùng sau khi login thành công, sẽ được server trả về:
access_token : token để định danh người dùng (thời gian sống ngắn : 5 phút, 10 phút…) khi đã tạo ra thì ko thay đổi được -> set thời gian sống ngắn 

refresh_token : nếu access token bị hết hạn, sử dụng refresh token để renew (thời gian sống lâu hơn nhiều, thường là 1 ngày, 30 ngày … ) thường được lưu vào cookies 

=> access token được lưu tại Local Storage (frontend dễ dàng truy cập và sử dụng) . Đặt thời gian sống ngắn để giảm thiểu rủi ro

Refresh token được lưu tại cookies với mục đích là Server sử dụng (vì cookie luôn được gửi kèm với mỗi lời gọi request) => lưu ở cookies sẽ an toàn hơn (do thời gian sống của token lâu hơn access token)



//cơ chế hoạt động của cookies 
Có bao giờ bạn thắc mắc tại sao Facebook, Google, Tiktok… 1 tuần, 1 tháng , 1 năm… bạn không cần đăng nhập lại (trên cùng 1 máy tính) mỗi lần sử dụng ?

Câu trả lời là cookies.
Trong lần đăng nhập đầu tiên thành công, Server (FB, Tiktok…) sẽ trả về thông tin của người dùng và lưu vào cookies. 
Cookies này thường có thời hạn sống khá lâu (vài tháng tới cả năm)

=> sau vài tháng bạn vào lại, cookies sẽ đc sử dụng (refresh token) để đổi lấy access token mới => bạn không cần login lại :v


2. Luồng logic

//update thời gian của access và refresh token (chia thành 2 biến riêng lẻ)
hoidanit.jwt.token-validity-in-seconds=8640000 hiện tại chỉ để thời gian hết hạn chung chung của token -> cần tách ra 

//tạo refresh token (chứa user email)
Subject (sub) : đối tượng mà token này hướng tới (định danh user)
=> sử dụng email là ok

Claim (key: value): meta data => lưu gì cũng đc

 user:  {
        email: "hoidanit@gmail.com",
        name: "Hỏi Dân IT",
        id: "25"
       }



//update user với refresh token
Trong securityUtil.java thêm 1 hàm createRefreshToken nữa pần này sẽ xử lý tương tự createAccessToken (nhưng thời gian sống sẽ lâuu hơn) và ko được return về cho client ở pần body/header mà lưu nó vào cookies 

//set cookies to client (có thể test = postman)

##V - Set Cookies (Part 2)##
Tài liệu:
https://reflectoring.io/spring-boot-cookies/
link làm sẵn nếu code thuần MVC có thể dùng trực tiếp đối tượng Cookie 

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseCookie.html
đối với Spring có hỗ trợ class ResponseCookie -> có 1 hàm builder chỉ cần truyền vào tên và giá trị -> nó sẽ tự tạo cookies 

//update user với refresh token

set cookie
ResponseCookie responseCookie = ResponseCookie.from("refresh_token", refreshToken)
                .httpOnly(true)//tăng bảo mật chỉ có server mới lấy được cookie js ko lấy được
                .secure(true)// cookie chỉ được sử dụng cho https nếu ta dùng localhost -> builder này ko có tác dụng 
                .path("/")//cookie này áp dụng cho all đường link vào nếu set nó /api/v1 -> áp dụng cho những link bắt đầu = nó
                .maxAge(8640000)//thời gian sống nếu để mặc định sẽ là session 
                .domain("example.com")//ghi tên website -> chỉ áp dụng cookie cho web này nếu ko ghi thì website nào nó cũng gửi kèm cookie này domain ở đây ko set thì sẽ ứng với localhost 
		.build();

//set cookies to client (có thể test = postman)
// các thuộc tính thường dùng
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie

Path: url set cookie
Domain: nếu không set, thì chỉ chính same domain (không tính sub domain)

##VI - API Get Account (F5 - Refresh)##

Bài toán:
Với mô hình stateful, khi user F5 (refresh website), client sẽ gửi lên session_id (lưu ở cookies), server sẽ check session để biết user nào đang đăng nhập.

Với mô hình stateless, không có sử dụng session, thay vào đấy là access_token và refresh_token.

=> khi user F5, cần gọi API của backend, vì client không có khả năng decode (giải mã) access_token để biết được ai là người đang đăng nhập.

khi giải mã token -> thì nó lưu 1 claim user -> này là được thiết lập ở trong lưu tạo token -> lưu claim là nguyên cái authentication luôn trong này mục đích chính là lưu vai trò của người dùng -> được lưu trong user.princical.authorizies h mình sẽ customize lại cái này ko lưu authentication nữa mà lưu 1 DTO (chưa đụng tới role khi có sẽ add thêm) -> lúc này khi tạo token sẽ ngắn hơn vì lưu ít thông tin hơn trước 
JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuedAt(now)
            .expiresAt(validity)
            .subject(authentication.getName())//định danh người dùng là ai ở đây thì dùng với email
            .claim("user", authentication)//chỉ những thành pần biểu diễn cái object
            .build();

Yêu cầu:
Tạo endpoint: GET  /api/v1/auth/account

Chỉ cần truyền lên JWT ở header 

Response:

{
    "statusCode": 200,
    "message": "Get user information",
    "data": {
            "id": "....",
            "name": "...",
            "email": "...",
           }
}


##VII - Giải thích cơ chế JWT và Spring Security (Extra)##

Do sử dụng mô hình stateless (tách riêng frontend và backend), nên không thể sử dụng session, chúng ta sử dụng token để định danh người dùng.

Để truy cập endpoint (APIs) tại backend, đối với mỗi lời gọi (request), frontend cần truyền thêm Token (gọi là access token). Token này sẽ được gán ở header mỗi request (Bearer Token)

Access Token này có thời gian sống ngắn (thực tế được dùng từ 30 phút tới 1 ngày) để đảm bảo an toàn, đồng thời, được viết dưới dạng JWT (JSON Web Token)

1. API Login
POST http://localhost:8080/api/v1/auth/login
Mục đích: client (frontend) lấy được access token để truy cập API backend, đồng thời có được refresh token (sử dụng khi access token hết hạn)

Cơ chế xử lý tại backend:
Xử lý đăng nhập với Spring Security, và nếu đăng nhập thành công, tạo ra access token, bao gồm 2 thành phần:

subject (sub): đối tượng của Token (đảm bảo tính duy nhất), sử dụng email là hợp lý
claim : thông tin miêu tả về token

Ví dụ về access token (chứa user)

eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJob2lkYW5pdEBnbWFpbC5jb20iLCJleHAiOjE3MjQwNTkzNTEsImlhdCI6MTcxNTQxOTM1MSwidXNlciI6eyJpZCI6MSwiZW1haWwiOiJob2lkYW5pdEBnbWFpbC5jb20iLCJuYW1lIjoiSOG7j2kgRMOibiBJVCJ9fQ.0V3Ss4AWnHf8f6HtSEWKlchHSJAmHW0ef3WUtDj2fn0vGYEjbyqIO2nor0lq06DTcAOAthT9BBvQ3gD9M0jThw


Ví dụ về access token (chứa user và permission)
eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJob2lkYW5pdEBnbWFpbC5jb20iLCJwZXJtaXNzaW9uIjpbIlJPTEVfVVNFUl9DUkVBVEUiLCJST0xFX1VTRVJfVVBEQVRFIl0sImV4cCI6MjU3OTQ3NjQ0MCwiaWF0IjoxNzE1NDc2NDQwLCJ1c2VyIjp7ImlkIjoxLCJlbWFpbCI6ImhvaWRhbml0QGdtYWlsLmNvbSIsIm5hbWUiOiJI4buPaSBEw6JuIElUIn19.Wa0Cc0zx9AgGpWYpZ3Ucjk5PyENCNDAsdjpoZnOY06jRnk4hpFf9cFyZfrvWWKZI839JX7_gSZ56TTXMrV9dFw

2. Với tất cả các API khác (cần truyền access token ở header)
-> sử dụng mặc định của Security thêm những thông tin cần vào thuộc tính đã có trog authentication 
-> còn nếu muốn gửi thêm những thông tin khác chỉ có thể override lại User mặc định của hệ thống 

-> muốn lưu thêm ngoài thông tin user thì + builder thêm 1 claim nữa (claim có thể lưu nhiều): 
//add claim permission
        List<String> listAuthority = new ArrayList<String>();
        listAuthority.add("ROLE_USER_CREATE");
        listAuthority.add("ROLE_USER_UPDATE");
	...
	.claim("permission", listAuthority) 
(claim ở đây được mã hóa trong token nhưng khi trả ra request chúng t ko trả ra nó nên sẽ ko hiển thị để xem thì có thể dịch token trên jwt.io)
ở đây thì thêm claim permission thông tin ở đây sẽ được lưu vào SecurityContext đc set ở hàm convert JWT -> authentication: grantedAuthoritiesConverter.setAuthoritiesClaimName("permission"); khi set vào setAuthoritiesClaimName thì kiểu dữ liệu pải là các chuỗi String ko được là kiểu dữ liệu khác vì sẽ bị lỗi 

Khi gửi bất kì request nào cũng cần token vì đã set JWT ở config .oauth2ResourceServer((oauth2) -> oauth2.jwt(Customizer.withDefaults()) -> h nó đính kèm theo header thì: mỗi lần gửi request lên function đầu tiên nó chạy vào sẽ là jwtDecoder() sau đó nó chạy vào những class cần thiết đặc trưng

//tiền hành debug
//nạp quyền hạn (authority) từ jwt vào security context
JwtGrantedAuthoritiesConverter: sẽ chạy vào hàm convert(Jwt jwt) bởi vì đã cấu hình ở config việc grantedAuthoritiesConverter.setAuthoritiesClaimName("permission") -> tức là nó sẽ giải mã token lấy đi cái nào có nam="permission" -> nạp vào authentication mặc định của nó 
-> nó sẽ set authorities chạy vào hàm getAuthorities(Jwt jwt): trong này nó chỉ set 2 trường hợp sẽ set được thông tin vào là kiểu dữ liệu của permission pải là String || collection (nếu là collection thì những dữ liệu lưu trong collection này pải ép về kiểu String được nếu ko đc nó sẽ lỗi) 
cuối cùng nó trả về Collection<GrantedAuthority> 1 collection của Authority -> authentication

//filter
BearerTokenAuthenticationFilter: doFilter()-context.setAuthentication(authenticationResult) -> set authentication vào SecurityContext trong này có thuộc tính authorities chứa các quyền mà được set ở trên viêc set authories này bắt đầu từ việc cấu hình ở config và sử dụng ở việc pân quyền 1 API trong config .hasAuthority() -> sẽ lấy authority đã set để sử dụng ở đây

nhưng trong dự án này sẽ ko làm thủ công vậy (vì nếu muốn pần quyền cho nhiều API pải viết cho từng cái ...) 

chung quy lại thì vẫn đang dùng all things mặc định của Security chỉ điều chỉnh sơ giá trị lưu trong đó - chứ chưa thêm sửa thuộc tính gì

Khi gửi request gồm access token, hàm decode sẽ được chạy đầu tiên để giải mã token

//SecurityConfiguration.java
 return jwtDecoder.decode(token);

Kế tiếp, sẽ tiến hành nạp “authority” (quyền hạn) vào security context. Làm được điều này, do có:
    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
           grantedAuthoritiesConverter.setAuthoritiesClaimName("permission");

           return jwtAuthenticationConverter;
    }



##VIII - API Refresh Token (Part 1)##

1.Bài toán:
Client sử dụng API, và khi access_token hết hạn => server sẽ trả ra mã lỗi 401
https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401

Code 401 (unauthorized), có nghĩa là không xác thực được người dùng => người dùng không truyền lên access_token, hoặc có truyền lên access_token, nhưng hết hạn.

=> khi nhận code 401, client (frontend) sẽ tự động gọi API refresh_token, sử dụng token này để đổi lấy {access_token, refresh_token} mới.

2. Yêu cầu: tạo endpoint 

GET api/v1/auth/refresh

Response: (trả ra giống hệt như khi login)

{
    "statusCode": 200,
    "message": "Get User by refresh token",
    "data": {
       "accessToken": "...",
        "user": {
            "id": "...",
            "name": "...",
            "email": "...",
          }

    }
}


3. Các bước xử lý
Tài liệu:
https://reflectoring.io/spring-boot-cookies/

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseCookie.html

Server lấy ra refresh_token từ cookies

Server check (verify) để biết refresh_token có hợp lệ hay không ?

Server query database theo refresh_token 
=> lấy thông tin user 
=> issue access_token mới

Server trả ra phản hồi (set cookies ứng với refresh_token mới)


##IX - API Refresh Token (Part 2)##

//todo
Server query database theo refresh_token 
=> lấy thông tin user 
=> issue access_token mới

Server trả ra phản hồi (set cookies ứng với refresh_token mới)

##X - API Logout##

Yêu cầu: Tạo endpoint

POST api/v1/auth/logout

Truyền lên JWT ở header

Response : 
{
    "statusCode": 200,
    "message": "Logout User",
    "data": null
}

Xử lý ở backend:
Nhờ có spring security, lấy ra email của người dùng

Update refresh_token === null (empty) (tìm theo email)

Remove refresh_token ở cookies (remove cookies)
https://reflectoring.io/spring-boot-cookies/

Trả về phản hồi cho client : ResponseEntity<Void>

##X - API Logout##

Yêu cầu: Tạo endpoint

POST api/v1/auth/logout

Truyền lên JWT ở header

Response : 
{
    "statusCode": 200,
    "message": "Logout User",
    "data": null
}

Xử lý ở backend:
Nhờ có spring security, lấy ra email của người dùng

Update refresh_token === null (empty) (tìm theo email)

Remove refresh_token ở cookies (remove cookies)
https://reflectoring.io/spring-boot-cookies/

Trả về phản hồi cho client : ResponseEntity<Void>

##XI - Nguyên tắc check code frontend##

1.Rule tuân theo
Code frontend chỉ lỗi, khi và chỉ khi bạn không chạy lên được dự án frontend.

Tất cả các trường hợp còn lại, nếu đã chạy thành công dự án frontend, tuy nhiên, check giao diện không được kết quả như video hướng dẫn, cần check response của api, tức là lỗi của backend java.

Lỗi ở đây, là backend java đang viết API trả ra định dạng “không phải là thứ frontend mong muốn”.

API chạy được, nhưng cần đảm bảo trả ra đúng định dạng (format) mà frontend mong muốn

2. Danh sách API cần check trong module này
Fix bug 1 : https://stackoverflow.com/questions/12583638/when-is-the-jsonproperty-property-used-and-what-is-it-used-for
public class ResLoginDTO {
    @JsonProperty("access_token")
    private String accessToken;

//todo: fix bug còn lại
trong CorsCofig.class 
	thêm 1 số url để test frontend http://localhost:5173, http://localhost:4173
	setAllowedHeaders: x-no-retry 
-> xử lý lỗi cors 	
	

1.API login
POST http://localhost:8080/api/v1/auth/login

{
    "statusCode": 200,
    "error": null,
    "message": "CALL API SUCCESS",
    "data": {
        "access_token": "jwt token",
        "user": {
            "id": 1,
            "email": "hoidanit@gmail.com",
            "name": "Hỏi Dân IT"
        }
    }
}
2. API Get Account 
GET http://localhost:8080/api/v1/auth/account

{
    "statusCode": 200,
    "error": null,
    "message": "fetch account",
    "data": {
        "user": {
            "id": 1,
            "email": "hoidanit@gmail.com",
            "name": "Hỏi Dân IT"
        }

    }
}


3. API get refresh token
GET http://localhost:8080/api/v1/auth/refresh

{
    "statusCode": 200,
    "error": null,
    "message": "Get User by refresh token",
    "data": {
        "access_token": "jwt token",
        "user": {
            "id": 1,
            "email": "hoidanit@gmail.com",
            "name": "Hỏi Dân IT"
        }
    }
}

4. Các API về CRUD
=> check video bài tập CRUD

##XII -Test giao diện frontend##
Version node.js mình sử dụng là 16.20.0:
https://nodejs.org/download/release/v16.20.0/

Cài chính xác version để hạn chế tối đa lỗi có thể xảy ra. (nvm)

Kiểm tra đã cài đặt thành công với câu lệnh: node -v

Link dự án frontend download https://drive.google.com/file/d/1Dqh5yA6JPrfvSBjLhKTEqaSbKmXy924X/view?usp=sharing
Bước 1: 
Tải dự án thực hành ở trên (đã ứng với branch test-1)

Lưu ý về check file env, đảm bảo backend chạy chính xác port

Bước 2: cài đặt thư viện cần thiết
npm i

Bước 3: build dự án
npm run build

Bước 4: chạy dự án tại chế độ production
npm run preview

//test dự án = tab ẩn danh (hoặc cần clear hết cookies/localStorage ứng với port 3000)

Các tính năng test:
Login thành công, trả về token
Access token lưu tại Local Storage
Refresh token lưu tại Cookies

CRUD user User/Company http://localhost:3000/admin

Demo tính năng khi access token (test = cách setup tại backend) ( x-no-retry )
//bổ sung header để không bị cors


====Chapter 11: Modules Job/Resume====
Bài tập thực hành tạo module Job/Resume: CRUD job/resume, kết hợp việc sử dụng upload/download file với Java Spring

##I - Code Refactoring##

Tổ chức lại thư mục domain và service
Chia thành request/response

##II - 93. Model Relationship (Associations)##
Tài liệu: 
https://docs.jboss.org/hibernate/orm/6.4/introduction/html_single/Hibernate_Introduction.html#associations

https://www.baeldung.com/jpa-hibernate-associations

1. Phân loại
Gồm 3 loại quan hệ chính:

One to One : quan hệ 1 - 1
One to Many hay Many to One : quan hệ 1 - nhiều ( 1 - N )
Many to many : quan hệ nhiều - nhiều ( N - N )

Chỉ chiều hướng mối quan hệ (ràng buộc cha/con), chúng ta có 2 keywords:
unidirectional : quan hệ 1 chiều

bidirectional: quan hệ 2 chiều

Quan hệ giữa User - Company:
1 user chỉ thuộc 1 công ty ( 1 - 1 )
1 công ty bao gồm nhiều user ( 1 - N )
=> mối quan hệ giữa User và Company là N - 1

2. Áp dụng cho Model

1 user chỉ thuộc 1 công ty  => table User sẽ lưu company_id
N user cùng thuộc 1 công ty => ManyToOne
@ManyToOne
@JoinColumn(name = "company_id")
private Company  company;

1 công ty có nhiều user => OneToMany
@OneToMany( mappedBy = “company”)
List<User> users;


3. Fetch Lazy or Eager ?
https://www.baeldung.com/hibernate-lazy-eager-loading

https://stackoverflow.com/questions/2990799/difference-between-fetchtype-lazy-and-eager-in-java-persistence-api

Khác với Spring MVC thì ở đây ngoài việc xét ràng buộc của các Model -> làm thêm cách fetch data
Ví dụ model University {có List<Student>} -> lượng Student này rất lớn 
- Lazy: khi nào query trường university + yêu cầu query trường List đó thì nó mới Fetch lên
- Eage: khi nào query trường university -> nó sẽ tự động query List đó luôn (query all trong trường đó)

-> để tối ưu hóa thì khi nào chúng ta cần thì mới lên lấy các thông tin có lượng dữ liệu lớn khi query đến trường nào đó 
đối với dự án này -> sẽ set Lazy cho List<User> ở company


##III - Bài Tập Update Model User/Company##
Yêu cầu 1: Tạo user, kèm thêm thông tin của công ty
POST http://localhost:8080/api/v1/users
{
    "name" : "Hỏi Dân IT",
    "email": "hoidanit@gmail.com2",
    "password": "123456",
    "gender": "MALE",
    "address": "ha noi",
    "age": 25,
    "company": {
        "id": 17
    }
}

sửa lại UserService 2 th:
- khi tạo user có gửi thêm id của công ty: tìm công ty theo id -> gán công ty vào user, nếu ko tìm thấy gán = null
- ko gửi thêm tên của công ty (null)

//logic xử lý tại backend, nếu truyền thêm company, cần check xem company đấy có tồn tại hay không (check theo id)
Nếu công ty tồn tại => set data company cho user
Nếu công ty không tồn tại => set data = null

Yêu cầu 2: thêm thông tin company khi thao tác với user
//khi update use

//khi fetch user by id
//khi fetch all user

Yêu cầu 3: khi xóa công ty, cần xóa user thuộc công ty, rồi mới xóa công ty

//trong thực tế, có thể thêm 1 fields là active = true/false (chứ không xóa hết data)

Yêu cầu 4: khi fetch công ty, sẽ ignore (bỏ đi thuộc tính user)
//tránh lặp vô hạn: tức là mỗi lần lấy công ty -> lấy list user mà khi lấy user nó lại -> lấy ra công ty ...
-> dùng @JsonIgnore Khi dùng annotation này: ở frontend khi gửi thông tin company + list user(pần này sẽ bị bỏ k care), ở backend trước khi trả thông tin company cho người dùng cũng ko trả thông tin của list user


##IV - Model Job##

1.Tạo model Job

Table jobs:			
	id		long	
	name		String	
	location	String	
	salary		double	
	quantity	int	
	level		String	FRESHER/JUNIOR… => sử dụng enum (tương tự gender)
	description	String	longText
	startDate	Date	
	endDate		Date	
	isActive	boolean	
	createdAt	Date	
	updatedAt	Date	
	createdBy	String	
	updatedBy	String	
	company_id	long (mapping relationship)	
skills	Array	(mapping relationship)

//level : INTERN, FRESHER, MIDDLE, SENIOR

Table skills:
	id 	long
	name	String 
	createdAt	Date	
	updatedAt	Date	
	createdBy	String	
	updatedBy	String	

2. Định nghĩa relationship
Quan hệ giữa Company - Job:
1 công ty có thể đăng tuyển nhiều jobs ( 1 - N )
1 job chỉ thuộc 1 công ty ( 1 - 1)

=> mối quan hệ giữa Company và Job là 1 - N
//company
@OneToMany(mappedBy = "company", fetch = FetchType.LAZY)
@JsonIgnore
List<Job> jobs;

//job
@ManyToOne
@JoinColumn(name = "company_id")
private Company company;

Quan hệ giữa Job - Skill:
1 job có nhiều kỹ năng (skill) ( 1 - N )
1 skill có thể thuộc nhiều job khác nhau ( 1 - N)

=>  mối quan hệ giữa Job và Skill là N-N
//job
@ManyToMany(fetch = FetchType.LAZY)
@JsonIgnore
@JoinTable(name = "job_skill", joinColumns = @JoinColumn(name = "job_id"), inverseJoinColumns = @JoinColumn(name = "skill_id"))
private List<Skill> skills;

//skill
@ManyToMany(fetch = FetchType.LAZY, mappedBy = "skills")
@JsonIgnore
private List<Job> jobs;

việc thiết lập JoinTable hay mappedBy có thể thực hiện ngược lại (quan hệ nhiều nhiều thì nó có qan hệ 2 chiều)
-> sau khi thiết lập sẽ tự động tạo 1 bảng mới chỉ có 2 thuộc tính là job_id và skill_id

##V -  CRUD Job##

//rename isActive => active (table job)
@ManyToMany(fetch = FetchType.LAZY)
@JsonIgnoreProperties(value = { "jobs" })
private List<Skill> skills;

@JsonIgnoreProperties(value = { "jobs" }) dùng annotation này -> sẽ tránh được trường hợp lặp vô hạn + nhưng vẫn lấy được thuốc tính của Skills: tức là nếu dùng @JsonIgnore nó sẽ ở frontend truyền vào sẽ được bỏ qa, backend sẽ ko lấy cái này từ db truyền lên view, còn dùng JsonIgnoreProperties là chỉ bỏ 1 trường trong 1 model tức là vẫn lấy được skill nhưng ko lấy trường jobs trong skill đó -> tránh vòng lặp vô hạn khi lấy skills nó lại lấy list Jobs (mà trong Jobs nó lại lấy list Skills)



1. CRUD Skills

//Create a skill : tên skill là duy nhất và không được để trống
Body: truyền name
{  "name" : "JAVA" }

//update a skill : tên skill là duy nhất và không được để trống
Body: truyền name và id  

Với tính năng xóa skill, các bạn làm sau cùng nhé.
Làm thêm/sửa/get skills (bước 1)
Làm thêm/sửa/xóa/get job (bước 2)

Rồi hãy làm xóa skill (vì khi đấy đã đủ data và có ràng buộc về quan hệ) 

//delete a skill (không cần làm, vì khi delete job (owner side) sẽ tự động xóa trong job_skill
//bạn nào muốn làm, thì cần test 2 trường hợp:
Trường hợp 1: chưa có dữ liệu của job
Trường hợp 2: đã có dữ liệu của job (tức là table job_skill có dữ liệu của skill muốn xóa)
khi xóa skill: 
vì thiết lập mối quan hệ 2 chiều (N-N) giữa job và skill và bên job mình có định nghĩa @JoinTable -> Job là cha 

thì khi job là cha thì mỗi lần xóa Job Orm sẽ tự động xóa những dữ liệu liên qan đến job đó trong table job_skill nhưng khi xóa skill (con) thì nó sẽ ko làm mà mìh pải tự làm -> đầu tiên pải xóa hết job có liên qan đến skill đó trong table job_skill sau đó mới xóa skill đó được 

//fetch all skills with pagination



2. CRUD Job

//create a job
Tạo DTO để get list skills và trả ra phản hồi tương ứng
//cần check skills trước khi lưu
//data mẫu
{
	"name": "Dev Java",
	"location": "Hà Nội",
	"salary": "10000000",
	"quantity": 10,
	"level": "JUNIOR",
	"description": "BLA BLA",
	"startDate": "2024-05-04T13:55:58.454607Z",
	"endDate": "2024-05-04T13:55:58.454607Z",
	"active": true,
	"skills": [
		{
			"id": 500
		},
		{
			"id": 3
		}
	]
}



//update a job

//delete a job

//fetch all job with pagination

//get a job by id

##VI - Về Upload File##
Tham khảo:
https://spring.io/guides/gs/uploading-files

1.Có bao nhiêu cách để upload file (Storage)
Sử dụng dịch vụ : AWS S3 -> tốn pí
Lưu vào database (Blob): lưu trực tiếp vào database -> nhưng ko thể search ~ tốc độ đọc ghi chậm 
Lưu file vào server

2.Các khái niệm hay dùng:

MultipartFile
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/multipart/MultipartFile.html

//tượng trưng cho file gửi từ client lên server
//thay vì gửi text, chúng ta sử dụng binary

Path
https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html

//tượng trưng cho địa chỉ lưu trữ file trên máy tính của bạn


##VII - Read File From Path##

folder lưu file sẽ ko đặt trong folder chứa source code để tránh việc khi chạy ở chế độ production (như sử dụng docker) -> ko backup được

-> làm sao để truy cập được các loại file từ đường link localhost (việc lưu trữ file là của Backend việc truy cập là việc cho pép frontend có khả năng truy cập nó )

1. Cấu hình path
Phân loại path: https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#traditional-dos-paths

Lưu ý: về phần cấu hình, lưu ý check dấu cách (empty space)

//cấu hình base path (set up env), sử dụng absolute path cấu hình ở đây để nó không pải phụ thuộc vào loại máy (server chạy nó)
application.properties

Sử dụng câu lệnh để in ra path: pwd
//với windows, lưu ý chuyển \ thành /
D:\1.Udemy\Backend\4. Java Spring Restful\upload
=> được chuyển thành
D:/1.Udemy/Backend/4. Java Spring Restful/upload

Ví dụ:
hoidanit.upload-file.base-path=D:/1.Udemy/Backend/4. Java Spring Restful/upload/

2. Test access from localhost

Link download test file:
https://drive.google.com/drive/folders/1RmO4JdjpUPyCAO1HWQEANe486ExHh5Wg?usp=sharing


//cấu hình Spring
Đặt tên link là: localhost:8080/storage/file_name

//lưu ý về security


//StaticResourcesWebConfiguration.java
@Configuration
public class StaticResourcesWebConfiguration
        implements WebMvcConfigurer {

    @Value("${hoidanit.upload-file.base-path}")
    private String basePath;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/storage/**")
                .addResourceLocations(basePath);
    }
}


3. Security concern

Chỉ cho phép đọc file tại 1 nơi cố định 
Chỉ cho phép đọc file type nhất định


##VIII. Upload File##

Tạo API upload single file :
POST   http://localhost:8080/api/v1/files

Bước 1: Frontend gửi lên file và tên folder lưu trữ (Sử dụng form-data thay vì json)
file: file cần upload
folder: tên thư mục upload, phân theo từng tính năng

Bước 2: Backend lấy thông tin gửi lên
@PostMapping("/files")
public String upload(
    @RequestParam("file") MultipartFile file,
    @RequestParam("folder") String folder
) 

Tham khảo:
https://spring.io/guides/gs/uploading-files
https://www.bezkoder.com/spring-boot-file-upload/

Bước 3: create a folder if not exists
https://stackoverflow.com/a/53252034

 public void createUploadFolder(String folder) throws URISyntaxException {
        URI uri = new URI(folder);
        Path path = Paths.get(uri);
        File tmpDir = new File(path.toString());
        if (!tmpDir.isDirectory()) {
            try {
                Files.createDirectory(tmpDir.toPath());
                System.out.println(">>> CREATE NEW DIRECTORY SUCCESSFUL, PATH = " + folder);
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println(">>> SKIP MAKING DIRECTORY, ALREADY EXISTS");
        }
    }



Bước 4: save file to folder

public void store(MultipartFile file, String folder) throws URISyntaxException, IOException {
       // create unique filename
        String finalName = System.currentTimeMillis() + "-" + file.getOriginalFilename();

        URI uri = new URI(basePath + folder + "/" + finalName);
        Path path = Paths.get(uri);
        try (InputStream inputStream = file.getInputStream()) {
            Files.copy(inputStream, path,
                    StandardCopyOption.REPLACE_EXISTING);
        }
    }

Bước 5: trả về phản hồi với file name
fileName: uploaded-file-name

Bước 6: validate file upload
File is empty

File extensions

File size (max = 5MB)

    
    String fileName = file.getOriginalFilename();
        List<String> allowedExtensions = Arrays.asList("pdf", "jpg", "jpeg", "png", "doc", "docx");
        List<String> allowedMimeTypes = Arrays.asList(
            "application/pdf", 
            "image/jpeg", 
            "image/png", 
            "application/msword",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        );

        // Validate extension
        boolean isValidExtension = allowedExtensions.stream().anyMatch(ext -> fileName.toLowerCase().endsWith("." + ext));
        if (!isValidExtension) {
            return ResponseEntity.badRequest().body("Invalid file type based on extension.");
        }

        // Validate MIME type
        String contentType = file.getContentType();
        if (!allowedMimeTypes.contains(contentType)) {
            return ResponseEntity.badRequest().body("Invalid file type based on MIME type.");
        }

        // Check file size
        long maxSize = 5 * 1024 * 1024; // 5 MB in bytes
        if (file.getSize() > maxSize) {
	//todo
        }

##IX - Download a File (Extra)##
Tham khảo: https://stackoverflow.com/questions/35680932/download-a-file-from-spring-boot-rest-service

##X - Model Resume##

id	long
email	String
url	String
status: enum// PENDING-REVIEWING-APPROVED-REJECTED
createdAt	Date
updatedAt	Date
createdBy	String
updatedBy	String
user_id	
job_id	

//
Xác định mối quan hệ:

User - resume : 1 - N

Job - resume : 1 - N

##XI - Test giao diện Frontend (Part 1)##

//fetch company by id

//allow public access
@PreAuthorize("permitAll()") ??? dùng Annotation này trang trí cho 1 controller để khỏi cần đăng nhập nhưng vẫn gọi được API: là ko được vì nó sẽ chạy vào filter chain trước khi nó chạy vào controller -> nếu ko khai báo url trong filter chain nó vẫn 

//check api first

//quy định thư mục upload
company: chứa logo công ty
resume: chứa cv ứng viên gửi lên
user: chứa avatar user


==== Chapter 12: Modules Permission & Role ====
Bài tập thực hành tạo module Permission/roles : CRUD Permissions/role, kết hợp áp dụng Spring  Life Cycle để tạo fake data cho dự án Backend.

## I -  Model Permission & Roles ##

permissions		
	id	long
	name	String
	apiPath	String
	method	String
	module	String
	createdAt	Date
	updatedAt	Date
	createdBy	String
	updatedBy	String

roles		
	id	long
	name	String
	description	String
	active	boolean
	createdAt	Date
	createdBy	String
	updatedAt	Date
	updatedBy	String
	permissions	Array

//xác định mối quan hệ giữa Permissions (quyền hạn) và Roles (vai trò)
1 Roles (Vai trò) có nhiều Permissions (quyền hạn)

1 quyền hạn có thể thuộc nhiều role 

=> N Roles - N Permissions => cần join_table (tương tự jobs-skills)

## II - Update User với Permissions & Roles ##
1.Cập nhật mối quan hệ giữa User và Role
//user.java
@ManyToOne
@JoinColumn(name = "role_id")
private Role role;

//role.java
@OneToMany(mappedBy = "role", fetch = FetchType.LAZY)
@JsonIgnore
List<User> users;

2. Update API Users
//update CRUD user với Role

//update login thành công (refresh, get account), trả thêm role/permission cho frontend

3. Bổ sung
//bỏ điều kiện update role by name (vì có thể update permissions, ko update name)

//viết api fetch resume by user: callFetchResumeByUser
https://github.com/turkraft/springfilter/issues/363

https://github.com/turkraft/springfilter/issues/233#issuecomment-1590045915

## III - Tạo Fake Data với SQL ##
1.Bổ sung
viết api register : /api/v1/auth/register
//fetch role by id
//update api update permission

2. Xóa tất cả table
https://stackoverflow.com/a/3476803

làm thủ công chạy lệnh sql

SET FOREIGN_KEY_CHECKS = 0;
drop table if exists companies;
drop table if exists jobs;
drop table if exists job_skill;
drop table if exists permission_role;
drop table if exists permissions;
drop table if exists resumes;
drop table if exists roles;
drop table if exists skills;
drop table if exists users;
SET FOREIGN_KEY_CHECKS = 1;

3.Tạo fake data
Link download file sql (và logo):
https://drive.google.com/drive/folders/1RmO4JdjpUPyCAO1HWQEANe486ExHh5Wg?usp=drive_link


Thứ tự tạo fake data:
Tạo users
Tạo companies
Tạo skills
Tạo jobs
Tạo job_skill


## IV - Test Giao Diện Frontend (Part 1) ##
Download dự án frontend: https://drive.google.com/file/d/1WslzVpUgyPmrvN_RXZ7-rAruMFyTb81G/view
Với file .env.production và .env.development,  các bạn sửa tham số: VITE_ACL_ENABLE=false
=> Nếu không sửa, khi test giao diện, sẽ không thấy menu chức năng (sidebar bên trái)

## V - Tạo Sample Data ##
(Part 1)
Tài liệu: https://docs.spring.io/spring-boot/how-to/data-initialization.html

//quản lý version database với liquibase
https://www.baeldung.com/liquibase-refactor-schema-of-java-app

//các cách tạo fake data với faker
https://www.baeldung.com/java-faker

//tạo câu lệnh query database
//viết code để tạo database (dựa vào life cycle)

(Part 2)
Tài liệu:
https://stackoverflow.com/a/41644743

https://docs.spring.io/spring-boot/api/java/org/springframework/boot/CommandLineRunner.html

Ý tưởng: sử dụng interface CommandLineRunner

Bước 1:
//DatabaseInitializer.java
public class DatabaseInitializer implements CommandLineRunner {
     @Override
    public void run(String... args) throws Exception {
        // TODO Auto-generated method stub
        System.out.println("RUN HERE");
        throw new UnsupportedOperationException("Unimplemented method 'run'");
    }
}

Ban đầu khi chỉ mới thêm class này và override lại hàm mặc định của functional interface này thì khi chạy chương trình lên không có gì hết ngay cả RUN HERE cũng không hiển thị
-> khi nào thi interface này nó chạy -> thực tế là interface này chạy lên khi ứng dụng java nó chạy lên đó cũng là quá trình tạo hay nạp các Bean lên (DJ) -> mình phải biến class này thành 1 cái Bean để biến nó thành 1 thành phần của java Spring
-> ví dụ thêm Annotation @Service cho class -> thì khi ứng dụng chạy lên nó sẽ tự động được nạp vào IOC hay Java Spring Container -> interface đó sẽ được chạy

Bước 2: init data
//coding (tham khảo source code cung cấp https://drive.google.com/file/d/1zd_ILvIcj8FFdAwNXOYGK07IhMM_vg74/view)
Admin thì full quyền: admin@gmail.com

//tạo permissions

//tạo roles, gán full permission cho role

//tạo users, gán role cho user

Bước 3: Xóa table
SET FOREIGN_KEY_CHECKS = 0;
drop table if exists permission_role;
drop table if exists permissions;
drop table if exists resumes;
drop table if exists roles;
drop table if exists users;
SET FOREIGN_KEY_CHECKS = 1;

Bước 4: Test data

## VI - Test Giao Diện Frontend (Part 2)##

Với file .env.production và .env.development,  các bạn sửa tham số: VITE_ACL_ENABLE=true

//update security
https://stackoverflow.com/a/74633151

1.Test giao diện Frontend
Version node.js mình sử dụng là 16.20.0:
https://nodejs.org/download/release/v16.20.0/

Cài chính xác version để hạn chế tối đa lỗi có thể xảy ra. (nvm)

Kiểm tra đã cài đặt thành công với câu lệnh: node -v

Download dự án frontend https://drive.google.com/file/d/1WslzVpUgyPmrvN_RXZ7-rAruMFyTb81G/view

(đã ứng với branch test-3-final)


//bonus 
tính năng search
update filter resume. HR chỉ xem được cv của cty HR


//Test phân quyền


## VII - Cách xử lý phân quyền tại Frontend (Extra)##

Để có thể hide/show giao diện ứng với phân quyền (quyền hạn), frontend sẽ cần biết Role (vai trò) và Permission (quyền hạn) của người dùng đăng nhập.

=> khi login/refresh token/getAccount (F5), backend cần trả ra role và permission cho frontend

Tại giao diện frontend, thực chất là viết if/else để render giao diện
On/off với tham số: VITE_ACL_ENABLE=true/false

Các keywords để xử lý phân quyền phía frontend:

Lưu trữ quyền hạn mà backend trả về (role/permission) ứng với người dùng đăng nhập. Với source code cung cấp, data được lưu tại redux

Khai báo list permission tại Frontend, file permissions.ts 
(hoặc viết api fetch tất cả permissions, lưu vào localStorage/IndexedDB)

Viết component access.tsx

Component trên là component cha, bọc ngoài các component con “cần check quyền hạn”

<Access
         permission={ALL_PERMISSIONS.COMPANIES.UPDATE}
         hideChildren
                    >
                        <EditOutlined
                                onClick={() => {
                                setOpenModal(true);
                                setDataInit(entity);
                            }}
                        />
</Access >

## VIII - Interceptor ##

khái niệm này tương tự như middleware ở đây sẽ can thiệp vào giữa lời gọi request và response 

Tham khảo:
https://stackoverflow.com/a/40291647

https://www.baeldung.com/spring-mvc-handlerinterceptor

https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html

//get pattern
https://stackoverflow.com/a/57242149

1. Cách làm
Mặc định, với 1 lời gọi request từ client gửi lên:

Request => Spring Security (Filter chain) => Controller => Service…

Do chúng ta “không sửa Spring Security” => sẽ can thiệp vào controller

=> can thiệp vào request sau khi đã qua Spring Security và trước khi gọi tới Controller (làm tương tự như FormatRestResponse -> trước khi trả ra kết quả thì format lại)

=> Interceptor

Mô hình:

Request => Spring Security => Interceptor => Controller => Service…

Ý tưởng:
Mỗi lời gọi request đều kèm theo JWT (access token) => chúng ta biết được ai đang đăng nhập (email) => biết được user đấy có quyền hạn (permissions) gì

Check target controller (url) và permission user có. Nếu tồn tại, cho request đi tiếp, còn ngược lại, ném ra exceptions
Bước 1: Khai báo interceptor
//PermissionInterceptor.java

public class PermissionInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(
            HttpServletRequest request,
            HttpServletResponse response, Object handler)
            throws Exception {

      String path = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);
        String requestURI = request.getRequestURI();
        String httpMethod = request.getMethod();
        System.out.println(">>> RUN preHandle");
        System.out.println(">>> path= " + path);
        System.out.println(">>> httpMethod= " + httpMethod);
        System.out.println(">>> requestURI= " + requestURI);

        return true;
    }
}

HandlerInterceptor xử lý các hành động trước/sau khi chạy vào controller thông qua 2 hàm cần override nếu muốn sử dụng
    - preHandle: xử lý trước khi vào controller - hàm này có kiểu dữ liệu trả về Boolean -> true thì đi tiếp qa controller/false thì sẽ dừng chương trình lại ko cho tới controller nữa
    - postHandle: xử lý sau khi vào controller
    * ngoài ra còn có sau khi hoàn thành 1 request: sử dụng afterCompletion

khi cấu hình như trên thì chạy chương trình lên vẫn chưa có gì xảy ra vì chưa có cấu hình cho Spring biết cần phải chạy qua Interceptor trước khi vào controller khi gửi 1 request

//Khai báo tại phần config WebMvcConfigurer
PermissionInterceptorConfiguration.java
@Configuration
public class PermissionInterceptorConfiguration implements WebMvcConfigurer {
    @Bean //mục đích sử dụng Bean ở đây là như DJ mỗi lần chạy ứng dụng nó sẽ tự động tạo class PermissionInterceptor và ném xuống cho addInterceptors sử dụng chứ ko cần new tạo nhiều lần
    PermissionInterceptor getPermissionInterceptor() {
        return new PermissionInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        String[] whiteList = {
                "/", "/api/v1/auth/**", "/storage/**",
                "/api/v1/companies", "/api/v1/jobs", "/api/v1/skills", "/api/v1/files"
        };
        registry.addInterceptor(getPermissionInterceptor())
                .excludePathPatterns(whiteList);
    }
}

Khi cấu hình ở đây thì nhưng API nằm ngoài whiteList khi được gửi request sẽ phải chạy qua interceptor trước khi vào controller


Bước 2: Check Permissions
Mô hình:
Request => Spring Security => Interceptor => Controller => Service…

Request gửi kèm JWT (access_token) => Spring giải mã token, và lưu thông tin vào Security Context

=> trước khi tới Interceptor, chúng ta đã biết được email của user

=> query user theo email => lấy role => lấy permission của user

## IX - Test Giao Diện Frontend (Part 3) ##
1. Giải thích về Transactional
cần dùng @Transactional này cho hàm hoặc class PermissionInterceptor phần này thường hỗ trợ giải quyết các bài toán khi số lượng người dùng lớn

- Kiểu khi 1 món hàng trên sàn thương mại điện tử chỉ còn 1 món mà trong khi đó nhiều người mua cùng lúc ?? thì Transactional nó sẽ hỗ trợ được gói 1 request thành 1 block và mỗi block khi hoàn thành sẽ cập nhật thông tin cho block được tạo ra sau (queue) hoặc nó có thể tham gia vào rollback (khi lỗi xử lý)
- còn ở bài toán của dự án này thì nếu ko thêm annotation đó vào khi chạy nó sẽ bị lỗi "... no session ..." (session ở đây là 1 piên đăng nhập xuôngs database hay 1 query xuống) vì chương trình chưa đi tới controller nên chưa có session nào xuống database
    Lỗi cụ thể nằm ở 
        Role role = user.getRole();
        List<Permission> permissions = role.getPermissions();
    mà đối với list permissions trong class Role load lên với kiểu LAZY -> có nghĩa là khi ta lấy role từ User thì trong role đó chưa hề có permissions 
    -> cần phải query xuống database 1 lần nữa do vậy nếu không có Transactional nó chỉ query xuống 1 lần đầu 
    khi có Transactional thì khi query lần đầu thì nó sẽ vẫn giữ nguyên cái phiên đăng nhập đó để giúp query lần 2

    Transactional ở đây giúp nói cho Spring biết là hãy quan sát cái hàm/class khi thao tác với interceptor này tạo cho nó 1 phiên đăng nhập để kết nối được xuống database (khi kết thúc thì xóa nó đi)
        (kiểu đảm bảo 1 hàm/class có thể kết nối xuống database 1 cái bth)  

2. Test giao diện frontend
    (đã ứng với branch test-3-final)


===== Chapter 13: Modules Subscribers ====
Bài tập CRUD subscribers, đồng thời tìm hiểu cách gửi email với Nest.js sử dụng “template xây dựng sẵn”, kết hợp với “cron jobs” để gửi email tự động.

## 1- Model Subscribers ##

//Subscriber.java
id: long
name: String
email: String

@ManyToMany(fetch = FetchType.LAZY)
@JsonIgnoreProperties(value = { "subscribers" })
@JoinTable(name = "subscriber_skill", joinColumns = @JoinColumn(name = "subscriber_id"), inverseJoinColumns = @JoinColumn(name = "skill_id"))
private List<Skill> skills;


//Skill.java
@ManyToMany(fetch = FetchType.LAZY, mappedBy = "skills")
@JsonIgnore
private List<Subscriber> subscribers;

## II - Bài tập CRUD Subscribers ##

Lưu ý: truyền token ứng với tài khoản admin@gmail.com (full quyền, và đã gán quyền crud với subscribers)

Viết 3 API (in đậm bên dưới):

CRUD Subscribers (làm tương tự như CRUD jobs, cần check các điều kiện cần thiết)

Create a subscriber
POST http://localhost:8080/api/v1/subscribers

Check trùng email, check skills truyền lên (tương tự như job) 
	
	Data mẫu:
{
    "email": "admin@gmail.com",
    "name": "Eric",
    "skills": [
        {"id": 1 },  {"id": 2 }
    ]
}

Update a subscriber (chỉ update skills)
PUT http://localhost:8080/api/v1/subscribers

check skills truyền lên (tương tự như job) 

{
    "id": 1,
    "skills": [
        {"id": 1 },  {"id": 3 }
    ]
}

Không cần làm API fetch data và xóa, vì không làm tại admin

Update API Delete a Skills => cần xóa subscriber_skill

## III - Cấu hình Send Email với Spring ##
Tham khảo:
https://docs.spring.io/spring-framework/reference/integration/email.html
https://www.baeldung.com/spring-email

1. Cài đặt thư viện
// https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail
implementation("org.springframework.boot:spring-boot-starter-mail")

Mô hình gửi mail:
Client gửi request tới server Java Spring -> gọi server Gmail -> gửi mail tới client
(khi gửi request tới server java spring thì ở đây nó ko tự động gửi được email vì đây là http Server không phải server gửi email như smtp
    -> ở đây chúg ta ko viết server gửi email mà sử dụng dịch vụ phổ biến free là Gmail )

2. Tạo app password với Gmail
Ngôn ngữ sử dụng là tiếng anh
Tài khoản Gmail cần bật xác thực 2 lớp
https://myaccount.google.com/apppasswords

3. Cấu hình tham số môi trường
https://docs.spring.io/spring-boot/appendix/application-properties/index.html#appendix.application-properties.mail

https://stackoverflow.com/questions/16594855/where-to-find-all-available-java-mail-properties

spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=your-email
spring.mail.password=your-gmail-app-password
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
-> Phần cấu hình này thì thay email + password = app password để tăng tính bảo mật và private dùng mật khẩu này để giao tiếp giữa server với server 

## IV - Send Email với Template (Part 1)##

Tham khảo https://drive.google.com/file/d/1b23urbqqJUmUhH28ENbIMu57-b8lmrk3/view

Lưu ý với hàm gửi email. Viết try/catch để bắt exception

Mục tiêu:
Cấu hình template engine
Gửi email với template ở trên

1.Vấn đề đặt ra
Gửi email với text đơn thuần thường có giao diện “khá xấu”. Chúng ta muốn có màu sắc, và với giao diện web (giao diện đọc email), chúng ta sẽ cần CSS

Chúng ta muốn tái sử dụng “format gửi email” để gửi cùng lúc cho nhiều khách hàng khác nhau.

=> template engine ra đời

2.  Sử dụng Thymeleaf template

Bước 1: Cài đặt thư viện
Khi generate project, mình đã tích hợp sẵn thymeleaf cho spring

implementation("org.springframework.boot:spring-boot-starter-thymeleaf")
implementation("org.thymeleaf.extras:thymeleaf-extras-springsecurity6")

//todo: minh họa cách làm với https://start.spring.io/




Bước 2: Cấu hình template

//Gửi email với JavaMailSender
//gửi email với html
Tham khảo https://drive.google.com/file/d/1b23urbqqJUmUhH28ENbIMu57-b8lmrk3/view



public void sendEmailSync(String to, String subject, String content, boolean isMultipart, boolean isHtml) {
        // Prepare message using a Spring helper
        MimeMessage mimeMessage = this.javaMailSender.createMimeMessage();
        try {
            MimeMessageHelper message = new MimeMessageHelper(mimeMessage, isMultipart, StandardCharsets.UTF_8.name());
            message.setTo(to);
            message.setSubject(subject);
            message.setText(content, isHtml);
            this.javaMailSender.send(mimeMessage);
        } catch (MailException | MessagingException e) {
            System.out.println("ERROR SEND EMAIL: " + e);
        }
}

Giải thích: 
MimeMessage mimeMessage = this.javaMailSender.createMimeMessage(); tạo đối tượng này để gửi mail với text phức tạp hơn sử dụng JavaMailSender thay vì MailSender như cũ
    mimeMessage: đối tượng đầu vào 
    isMultipart: cho phép gửi email kèm theo hình ảnh hay tệp đính kèm 
    StandardCharsets.UTF_8.name() chuẩn kí tự gửi mail 

    to: người nhận
    subject: tiêu đề
    isHtml: có phải file html không

ví dụ:  this.emailService.sendEmailSync("2251052129trong@ou.edu.vn", "Test send mail", "<h1><b>Hello<B/></h1>", false, true);
nhưng nếu code trực tiếp html vào thì khó maintain -> khái niệm template engine ra đời

-> gửi mail với template 

//Gửi email với template
Tham khảo https://drive.google.com/file/d/1b23urbqqJUmUhH28ENbIMu57-b8lmrk3/view

public void sendEmailFromTemplateSync(String to, String subject, String templateName) {
        Context context = new Context();
        String content = this.templateEngine.process(templateName, context);
        this.sendEmailSync(to, subject, content, false, true);
}
với Context và SpringTemplateEngine được import từ thymeleaf
mục đích của việc dùng SpringTemplateEngine là để dịch file html -> text 
-> chúng ta chỉ cần định nghĩa các template html trong thư mục /resources/templates đây là cấu hình mặc định của thymeleaf -> dùng để gửi mail
    -> nếu để những file html ở nơi khác -> Spring sẽ ko hiểu 


//download file Template sử dụng trong video:
https://drive.google.com/drive/folders/1RmO4JdjpUPyCAO1HWQEANe486ExHh5Wg?usp=drive_link



Cách tạo ra template theo ý muốn:
- Code HTML và style CSS trong cùng 1 file (không code riêng lẻ HTML và css) => sử dụng css với tag <style> </style>
- Convert HTML/CSS => inline CSS
- Mặc định Gmail sẽ bỏ qua CSS ở phần header => để đảm bảo an toàn hơn cho người dùng (tránh nhúng link javascript ở header)
- Nên sử dụng layout table (không dùng css flex)

## V - Send Email với Template (Part 2) ##

1.Truyền data động cho template
https://www.thymeleaf.org/doc/articles/springmail.html

Tham khảo https://drive.google.com/file/d/1b23urbqqJUmUhH28ENbIMu57-b8lmrk3/view

Truyền data từ controller qua template: khi truyền dùng thymeleaf được gọi bên trong attribute của thẻ và ghi đè nội dung của thẻ

//todo: hardcode data, sử dụng vòng lặp để render data
Tạo full template (đang hardcode data)

Sử dụng vòng lặp với thymeleaf: https://stackoverflow.com/a/36745375


Format currency: https://stackoverflow.com/a/14165869

<span th:text="${#numbers.formatDecimal(job.salary, 0, 'COMMA', 0, 'POINT')}">
</span>

## VI - Send Email với Template (Part 3). ##

1.Lấy động data để send email

 public void sendSubscribersEmailJobs() {
        List<Subscriber> listSubs = this.subscriberRepository.findAll();
        if (listSubs != null && listSubs.size() > 0) {
            for (Subscriber sub : listSubs) {
                List<Skill> listSkills = sub.getSkills();
                if (listSkills != null && listSkills.size() > 0) {
                    List<Job> listJobs = this.jobRepository.findBySkillsIn(listSkills);
                    if (listJobs != null && listJobs.size() > 0) {

                        // List<ResEmailJob> arr = listJobs.stream().map(
                        // job -> this.convertJobToSendEmail(job)).collect(Collectors.toList());

                        this.emailService.sendEmailFromTemplateSync(
                                sub.getEmail(),
                                "Cơ hội việc làm hot đang chờ đón bạn, khám phá ngay",
                                "job",
                                sub.getName(),
                                listJobs);
                    }
                }
            }
        }
    }


Lưu ý: cần update thêm cho constructors như bên dưới ae nhé

    private final SubscriberRepository subscriberRepository;
    private final SkillRepository skillRepository;
    private final JobRepository jobRepository;
    private final EmailService emailService;

    public SubscriberService(
            SubscriberRepository subscriberRepository,
            SkillRepository skillRepository,
            JobRepository jobRepository,
            EmailService emailService) {
        this.subscriberRepository = subscriberRepository;
        this.skillRepository = skillRepository;
        this.jobRepository = jobRepository;
        this.emailService = emailService;
    }

2. Sử dụng async để gửi email
tức là mình tăng tính trải nghiệm người dùng thực hiện đa luồng xử lý nếu gửi mail đó không ảnh hưởng đến logic của chương trình -> tách ra 2 luồng
    + luồng xử lý logic 
    + gửi mail
    chứ nếu phải đợi gửi mail xong thì mới xử lý logic phía sau rồi mới trả lại pản hồi cho người dùng thì không tối ưu
    -> nếu đã xử lý xong -> response gửi mail mình sẽ cho nó chạy luồng khác

Cần cấu hình: 
    @EnableAysync ở JobhunterApplication (class đầu tiên chạy vào)
    -> nếu function nào dùng bất đồng bộ thì trang trí nó = @Async ở đây chính là hàm sendEmailFromTemplateSync

Nếu chỉ cấu hình như vậy khi chạy API nó sẽ trả ra phản hồi ngay lập tức nhưng việc gửi mail sẽ bị fail (tức là không nhận được mail)
Giải thích cơ bản thì chương trình chạy nó sẽ chạy trên main thread thì chạy bất đồng bộ nó sẽ chạy 1 thread phụ khác nhưng luồng này mặc định không dùng được dữ liệu của main thread -> lỗi (dữ liệu cụ thể ở đây chính là dữ liệu query xuống database)
-> lỗi khi convert từ html trong templates sang văn bản. Lỗi này tương tự lúc dùng intercaptor và lúc đó sử dụng transactional để fix nhưng ở đây thì cụ thể ko biết transactional có fix được case này không
-> cần xử lý việc truyền dữ liệu giữa main thread và các thread phụ 

cơ bạn đối với SpringTemplateEngine (templateEngine) thì mình chỉ nên đưa dữ liệu cho nó (DTO: jobName, companyName, ...) chứ không nên để truy vấn như job.company.name ...khi dùng chấm như thế là đang gọi data của đối tượng (nhưng ở đây đang dùng lazy loading khi nào gọi tới nó mới query lại trên cái session khi lúc đầu)
ví dụ ở main thread khi lấy 1 job lên từ database (lưu session) thì nếu muốn lấy job.company -> ở main thread thì nó vẫn có session này -> nó vẫn lấy được data nhưng ở thread phụ không biết thread này -> lỗi 
https://www.danvega.dev/blog/sending-async-emails-in-spring

    public ResEmailJob convertJobToSendEmail(Job job) {
        ResEmailJob res = new ResEmailJob();
        res.setName(job.getName());
        res.setSalary(job.getSalary());
        res.setCompany(new ResEmailJob.CompanyEmail(job.getCompany().getName()));
        List<Skill> skills = job.getSkills();
        List<ResEmailJob.SkillEmail> s = skills.stream().map(skill -> new ResEmailJob.SkillEmail(skill.getName()))
                .collect(Collectors.toList());
        res.setSkills(s);
        return res;
    }


## VII -  Cron Job ##
Là một khái niệm trong hệ điều hành Linux 
đối với Spring có 1 topic được gọi là Task execution and scheduling phần mình áp dụng sẽ là Scheduling 

còn thuật ngữ Cron Job nó không phải xuất phát từ Java Spring mà từ hdh linux việc viết cron job có thể viết ở backend hoặc ngay trong database 
-> đơn giản ý tưởng là nó vẫn là 1 đoạn code nhưng được cấu hình để chạy tự động vào 1 khoản thời gian nào đó

Bất cứ nơi nào trong các component đều sử dụng được cron

(Part 1)

Tham khảo:
https://spring.io/blog/2020/11/10/new-in-spring-5-3-improved-cron-expressions

https://docs.spring.io/spring-framework/reference/integration/scheduling.html

1. Khái niệm cron job
https://en.wikipedia.org/wiki/Cron

Cron là cách chúng ta đặt lịch (schedule) để tự động làm một công việc gì đấy (job)



2. Cách viết cron job
https://docs.spring.io/spring-framework/reference/integration/scheduling.html#scheduling-cron-expression

https://spring.io/guides/gs/scheduling-tasks


Bước 1: enabled

@EnableScheduling


Bước 2: sử dụng schedule với cron
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html#cron()

@Scheduled(fixedRate = 5000) // truyền vào đây 1 expression hoặc 1 cron()
Annotation trang trí cho 1 function -> giúp nó chạy khi thỏa 1 điều kiện

(Part 2)

Cách viết cron job:
nếu cơ bản mình viết cron gửi mail tự động cứ 60s 1 lần @Scheduled(cron = "*/60 * * * * *") cho sendSimpleEmail của EmailController thì nó sẽ bị lỗi vì không có session khi truy vấn xuống database -> cần trang trí thêm @Transactional

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html#cron()

https://docs.spring.io/spring-framework/reference/integration/scheduling.html#scheduling-cron-expression

Tham khảo: https://stackoverflow.com/questions/45124756/spring-scheduling-cron-expression-for-everyday-at-midnight-not-working

## VIII - Nhận xét về dự án Frontend ##

1.Fix bug
Nên tách riêng API dành cho Client và API dành cho Admin => dễ phân quyền khi public API
Nên tách thành các API khác nhau endpoint và controller khác nhau như vậy việc phân quyền sẽ dễ hơn chỉ có những endpoint nào cho admin hoặc cho HR thì mới thêm check role và permission

//Code thêm tính năng download và giao diện subscribers
Bổ sung api:
POST /api/v1/subscribers/skills
=> lấy skill của user đã đăng ký


Test dự án frontend:

Version node.js mình sử dụng là 16.20.0:
https://nodejs.org/download/release/v16.20.0/

Cài chính xác version để hạn chế tối đa lỗi có thể xảy ra. (nvm)

Kiểm tra đã cài đặt thành công với câu lệnh: node -v

Download dự án https://drive.google.com/file/d/1-rEcbHZ2B5Xn3-fzRvEnSwzxKL10xkLx/view
(đã ứng với branch master)
2.Tổng kết ứng dụng:

Người dùng chưa đăng nhập:
Chức năng đăng ký/đăng nhập
Xem được danh sách công ty (company)
Xem được danh sách công việc (job)
Tìm kiếm job theo các tiêu chí (skill/location)

Người dùng đã đăng nhập:
Người dùng được tạo = /register (normal user, không được phân role):
Chức năng rải cv
Chức năng xem lịch sử rải cv
Chức năng đăng ký nhận email theo skill (subscribers)

Người dùng được phân quyền (theo permission và role):
Bản chất của 1 permission (quyền hạn), là 1 API khai báo tại backend
Người dùng admin (full quyền) được tạo = code
Cần kết hợp giữa frontend/backend để thực hiện việc phân quyền (mặc định chặn phân quyền tại backend theo Interceptor)
#117. Cách xử lý phân quyền tại Frontend (Bonus)
và #118. Interceptor


===== Tổng Kết =====
Tổng kết các kiến thức đã học và hướng dẫn tối ưu hóa dự án backend Java Spring

## I - Xử lý Global Exception ##

Lỗi đang default nhảy vào Custom Auth
ví dụ trường hợp gửi mail khi (không dùng bất đồng bộ) và lỗi code thymeleaf ở trong file html như cách gọi sai blabla ... nhưng nó vẫn hiển thị lỗi Forrbiden hoặc lỗi trong Interceptor
bơi vì thực tế trong SecurityConfiguration all lỗi liên quan đến quá trình sử dụng JWT nó sẽ nhảy vào customAuthenticationEntryPoint + trong case chúng ta không khai báo lỗi đó trong Global Exception thì customAuthenticationEntryPoint nó sẽ xử lý các lỗi đó

-> viết ngoại lệ cho các exception chưa được định nghĩa

    @ExceptionHandler(Exception.class)
    public ResponseEntity<RestResponse<Object>> handleAllException(Exception ex) {
        RestResponse<Object> res = new RestResponse<Object>();
        res.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
        res.setMessage(ex.getMessage());
        res.setError("Internal Server Error");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(res);
    }

## II - Swagger ##

1.Swagger là gì ?
https://swagger.io/docs/specification/about/

Mục đích chúng ta sử dụng Swagger, là tìm cách viết document (tài liệu) cho REST APIs.
Đi làm, có rất nhiều cách để viết “document”, và swagger là 1 trong số đó (và nên biết khi sử dụng với Java)

Link truy cập swagger: http://server:port/context-path/swagger-ui.html
context-path ở dự án này là '' rỗng ví dụ: http://localhost:8080/laptopshop -> chạy server laptopshop
                                           http://localhost:8080/jobhunter -> chạy server jobhunter
                                           thì đó chính là ứng dụng của context-path

2.Cài đặt
https://springdoc.org/#getting-started

implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")

Cấu hình Security: (allow access)
 "/v3/api-docs/**", chứa tất cả đường link API của server -> dạng json có thể convert vào postman nó sẽ tự động tạo nhưng API đó 
 "/swagger-ui/**",
 "/swagger-ui.html"

 khi chỉ mới cấu hình nhưng link này để nó không cần xác thực thì khi truy cập nó sẽ hiển thị các API mẫu mặc định đối của swagger

 khi truy cập vào các link này có thể bị lỗi RestResponse can not be cast to class do mình cấu hình trong formatResresponse nên nó bị lỗi tương tự như can not be cast to String 
 -> cấu hình thêm nếu truy cập vào những link swagger thì không làm gì cả

//FormatRestResponse.java
String path = request.getURI().getPath();
if (path.startsWith("/v3/api-docs") || path.startsWith("/swagger-ui")) {
      return body;
}

Truy cập swagger-ui tại: http://localhost:8080/swagger-ui/index.html
(với service = /v3/api-docs)


3.Cấu hình Swagger

- Thêm Bearer Token
- Hướng dẫn test api


Tham khảo: 
https://springdoc.org/#springdoc-openapi-core-properties

https://www.bezkoder.com/spring-boot-swagger-3/

https://www.baeldung.com/spring-boot-swagger-jwt

File cấu hình swagger trong video, tham khảo https://drive.google.com/file/d/1HsNJq5M13beJfGq9gqIbC34enKMZt8AL/view

## III -  Logging ##
quan trọng khi chạy ứng dụng thực tế (hỗ trợ cung cấp thông tin chạy thức tế của ứng dụng)

thực tế thì khi cài đặt Spring starter nó đã kèm theo loggin cơ bản rồi những thông tin chạy chương trình ở terminal chính là log để xem quá trình cũng như thông tin khi ứng dụng thực hiện hành động gì đó 

Tài liệu: https://docs.spring.io/spring-boot/how-to/logging.html

https://www.baeldung.com/spring-boot-logging

## IV - Build Dự Án với Docker ##
Yêu cầu để thực hiện video này: bạn cần có kiến thức cơ bản về docker
Nếu chưa biết gì, tham khảo:
https://www.youtube.com/playlist?list=PLncHg6Kn2JT4kLKJ_7uy0x4AdNrCHbe0n


Tại sao không deploy local ?

Tư duy khi viết dockerfile cho dự án:

Bước 1: sử dụng gradle để build dự án (mặc định thành file .jar)

Do chúng ta không sử dụng view (như khóa mvc), nên không cần build file .war

Bước 2: định nghĩa docker compose file

Ghi đè các tham số môi trường, như:
Thông tin kết nối tới database
Thông tin nơi lưu file upload

Tạo volume để backup database, và file upload

Bước 3: chạy dự án với docker compose

Do đã có file .jar (bước 1) => để chạy dự án, chỉ cần chuẩn bị môi trường java là chạy được

Link file docker mình sử dụng trong video, download https://drive.google.com/file/d/1ZQQJKjJbg24SOhew3Ckd7oCgReQ11hAo/view

## V - Nhận xét về cách code dự án Spring ##

Không có khái niệm, đâu là cách tốt ưu nhất để code dự án với Spring.

Điều quan trọng, là cách bạn code, cách bạn tổ chức code, phục vụ và giải quyết tốt cho bài toán bạn đang gặp phải.

Tuy nhiên, khi code, cần chú ý tới 3 yếu tố chính:

Code phải có khả năng mở rộng (phát triển cho tương lai, ví dụ thêm feature mới)
Code phải bảo trì được (maintain)
Code phải có khả năng test (viết testcase)

//Giải thích cách code với implement:
Cách code spring với implement

## VI - Cách tự tạo dự án  Spring Restful của bạn ##

1. Các lưu ý
Không nên chọn version Java mới nhất, vì có thể, thư viện (community) chưa kịp thời hỗ trợ => nên chọn 1 version “gần mới nhất” để đảm bảo tính ổn định.

Hãy chọn version java có từ LST (long term support)
https://www.oracle.com/java/technologies/java-se-support-roadmap.html

Nên chọn các version mới của Spring để nhận những update mới nhất (xịn nhất)
https://github.com/spring-projects/spring-framework/releases
https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions

Nếu bắt đầu dự án mới, bạn nên sử dụng Spring Framework từ version 6.x
(ứng với Spring Security 6.x và Spring Boot 3.x)

2.Cách tự tạo dự án của riêng bạn
Bạn có thể lấy lại dự án của mình (sử dụng trong khóa học) để code mở rộng thêm
Ưu điểm: bạn không cần phải “cấu hình”, ví dụ như Spring Security
Nhược điểm: bạn cần xóa code đi, để phục vụ dự án của bạn

Hoặc, tạo dự án từ đầu:
https://start.spring.io/

Lưu ý, cấu hình của trang : https://start.spring.io/ sẽ thay đổi theo thời gian (đây là lý do tại sao trong khóa học, mình yêu cầu kéo dự án từ github)

3.Cách bạn tự code dự án Spring từ đầu
Truy cập: https://start.spring.io/

Bước 1: Bạn chọn version Spring boot, chọn build tool, language và dependency

Dependency hay dùng như: jpa, chọn loại database, security

Bước 2: Nếu bạn chọn database, cần cấu hình thông tin đăng nhập vào database
Mình đã làm bước này trong khóa học, tại video #16

Bước 3: Tạo model cho dự án
Tạo base các model cho dự án và ràng buộc mối quan hệ (nếu có)

Đây chính là bước bạn cần phân tích database cho dự án của bạn, có thể chưa hoàn hảo, tuy nhiên cần code base các Model chính

Bước 4: Cấu hình Request/Response (nếu có)

Tại bước này, bạn nên off Security (disabled Spring Security)
//disable security
@SpringBootApplication(exclude = {
	org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class,
	org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration.class
})


Cấu hình Security với Password Encoder (video #48)
Sau đấy, tạo base CRUD User

Bước 5: Cấu hình Spring Security
Bao gồm viết file config cho Security và logic đăng nhập, cùng với JWT

Bạn không cần nhớ code, có thể tham khảo cách mình làm trong khóa học, điều quan trọng, là bạn hiểu bạn đang làm gì. Có thể debug để xem luồng code chạy

Bước 6: CRUD các tính năng cho dự án của bạn


## VII -  Nhận xét về dự án thực hành##

1.Nhận xét về dự án thực hành
Ưu điểm:
Thực hành sử dụng Spring như là backend Restful API với JWT (json web token)
Phân quyền dự án ở mức độ basic (với role và permissions)

Nhược điểm:
Nên tách riêng api dành cho client, dành cho admin
Không nên format response (để cho frontend tự format)

2. Các kiến thức chưa đề cập
- rate limit (throttle)
- actuator (loging, tracing...)
- Soft-delete: không nên xóa data

## VIII -  Giải Thích Về Lỗi RestResponse cannot be cast to class String

Tài liệu:
https://docs.spring.io/spring-framework/reference/6.2-SNAPSHOT/web/webmvc/message-converters.html

https://stackoverflow.com/questions/44121648/controlleradvice-responsebodyadvice-failed-to-enclose-a-string-response

1.Giải thích về cơ chế Message Converter của Spring
//debug
   if (!MediaType.APPLICATION_JSON.equals(selectedContentType)) {
            return body;
        }

        String path = request.getURI().getPath();
        if (path.startsWith("/v3/api-docs") || path.startsWith("/swagger-ui")) {
            return body;
        }

2. Cách debug để xem lỗi
AbstractHttpMessageConverter
Write -> addDefaultHeaders

StringHttpMessageConverter
protected void addDefaultHeaders(HttpHeaders headers, String s, @Nullable MediaType type) 

3. Cách khắc phục
Không nên can thiệp vào quá trình “mặc định” sử dụng MessageConverter của Spring, vì không rõ yêu cầu sẽ thay đổi như thế nào trong tương lai, và có thể ảnh hưởng tới các thư viện (third party), ví dụ trong khóa học là swagger.

## IX - Cấu Hình Lombok cho STS (Nếu Gặp Lỗi)

Mục tiêu của video: hướng dẫn cách fix dự án Spring sử dụng thư viện lombok, tuy nhiên không chạy được với Spring Tool Suite

Ví dụ: https://www.reddit.com/r/SpringBoot/comments/12im5y6/lombok_not_working_with_sts/

Bước 1: download lombok
https://projectlombok.org/download

Cần có file .jar của thư viện để thực thi bước 2

Bước 2: thực thi lombok

Sử dụng câu lệnh: java -jar lombok.jar

Chọn instance của Spring Tool Suite

Bước 3: Restart Spring Tool Suite
Clear cache
Build lại dự án
